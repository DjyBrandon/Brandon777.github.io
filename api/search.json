[{"id":"7ffde49d34885cb79e15d49bc1c3d82b","title":"Kunjing — HBU Competition","content":"坤竞——HBU竞赛组队匹配系统介绍：帮助河北大学师生营造更好的竞赛氛围，找到志同道合的伙伴，移动端 H5 网页（尽量兼容 PC 端），后续可加入科研方面。\n测试v1.0.0：http://kunjing.brandon777.com（未导入数据，前后端接口暂未接入）\n1 需求分析​        根据标签进行用户匹配，如：\n\n\n\n\n\n\n\n\n\n性别：男、女\n专业：软件工程、网络安全 ···\n正在准备/研究/进行：挑战杯、互联网+、大创、数模、蓝桥杯、CTF ···\n目标：挑战杯、互联网+、大创、数模、蓝桥杯、CTF ···\n（最高获奖）等级：未获奖、校级、省级、国家级\n身份：大一、大二、大三、大四、研一、研二、研三、博士、副教授、教授、企业\n\n用户信息\n支持Excel导入学生教务信息（模拟字段）√\n用户去添加/修改标签，标签的分类（要有哪些标签、怎么把标签进行分类）学习方向 挑战杯 / 互联网+ / 大创 ···（未开发完全）\n\n\n科研组队/竞赛组队\n创建队伍 √\n加入队伍 √\n解散队伍 √\n在线聊天（未开发)\n一起教室自习（接入智慧教务可视化）\n邀请其他人（未开发）\n\n\n查询搜索\n主动搜索：允许用户根据标签去搜索其他用户 √\nRedis 缓存 √\n\n\n根据标签查询队伍 √\n\n\n推荐匹配\n匹配标签相似学生 √\n匹配指导教师 √\n匹配公司投资 √\n相似度计算算法 + 本地分布式计算 √\n\n\n\n2 技术选型2.1 前端\nVue 3 开发框架（提高页面开发的效率）\nTypeScript（JavaScript 增强版）\nVant UI（基于 Vue 的移动端组件库）（React 版 Zent）\nVite 3（打包工具，快！）\nNginx 来单机部署\n\n2.2 后端\nJava 编程语言 + SpringBoot 框架\nSpringMVC + MyBatis + MyBatis Plus（提高开发效率）\nMySQL 数据库\n分布式 Session 登录\n数据查询 Redis 缓存\n缓存预热—定时任务\n控制定时任务—锁 + 分布式锁\nSwagger + Knife4j 接口文档\n\n3 数据库表设计及选择create\ndatabase if not exists kunjing;\n\nuse\nkunjing;\n3.1 用户表 user3.1.1 字段阐释\n\n\n\n字段\n名称\n类型\n\n\n\n\nid\n用户 id\nbigint\n\n\nusername\n昵称\nvarchar\n\n\nuserAccount\n登录账号\nvarchar\n\n\navatarUrl\n用户头像\nvarchar\n\n\ngender\n性别\ntinyint\n\n\nuserPassword\n密码\nvarchar\n\n\nprofile\n个人简介\nvarchar\n\n\nphone\n电话\nvarchar\n\n\nemail\n邮箱\nvarchar\n\n\nuserStatus\n状态 0 - 正常 1 - 封号\nint\n\n\ncreateTime\n创建时间\ndatetime\n\n\nupdateTime\n更新时间\ndatetime\n\n\nisDelete\n是否删除\ntinyint\n\n\nuserRole\n用户角色 0 - 普通用户 1 - 管理员\nint\n\n\nplanetCode\n星球编号\nvarchar\n\n\ntags\n标签 json 列表\nvarchar\n\n\n\n\n3.1.2 建表语句create table user\n(\n    username     varchar(256)                       null comment &#39;用户昵称&#39;,\n    id           bigint auto_increment              comment &#39;id&#39; primary key,\n    userAccount  varchar(256)                       null comment &#39;账号&#39;,\n    avatarUrl    varchar(1024)                      null comment &#39;用户头像&#39;,\n    gender       tinyint                            null comment &#39;性别&#39;,\n    userPassword varchar(512)                       not null comment &#39;密码&#39;,\n    profile      varchar(512)                       null comment &#39;个人简介&#39;,\n    phone        varchar(128)                       null comment &#39;电话&#39;,\n    email        varchar(512)                       null comment &#39;邮箱&#39;,\n    userStatus   int      default 0                 not null comment &#39;状态 0 - 正常&#39;,\n    createTime   datetime default CURRENT_TIMESTAMP null comment &#39;创建时间&#39;,\n    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,\n    isDelete     tinyint  default 0                 not null comment &#39;是否删除&#39;,\n    userRole     int      default 0                 not null comment &#39;用户角色 0 - 普通用户 1 - 管理员&#39;,\n    planetCode   varchar(512)                       null comment &#39;星球编号&#39;,\n    tags         varchar(1024)                      null comment &#39;标签 json 列表&#39;\n)\n    comment &#39;用户&#39;;\n3.2 队伍表 team3.1.1 字段阐释\n\n\n\n字段\n名称\n类型\n作用\n\n\n\n\nid\n主键\nbigint\n最简单、连续，放 url 上比较简短，但缺点是爬虫\n\n\n\n\n3.1.2 建表语句create table team\n(\n    id              bigint auto_increment               comment &#39;id&#39; primary key,\n    name            varchar(256)                        not null comment &#39;队伍名称&#39;,\n    avatarUrl       varchar(1024)                       null comment &#39;用户头像&#39;,\n    description     varchar(1024)                       null comment &#39;描述&#39;,\n    maxNum          int      default 1                  not null comment &#39;最大人数&#39;,\n    expireTime      datetime                            null comment &#39;过期时间&#39;,\n    userId          bigint                              comment &#39;用户id&#39;,\n    status          int      default 0                  not null comment &#39;0 - 公开，1 - 私有，2 - 加密&#39;,\n    password        varchar(512)                        null comment &#39;密码&#39;,\n    createTime      datetime default CURRENT_TIMESTAMP  null comment &#39;创建时间&#39;,\n    updateTime      datetime default CURRENT_TIMESTAMP  null on update CURRENT_TIMESTAMP,\n    isDelete        tinyint  default 0                  not null comment &#39;是否删除&#39;\n)\n    comment &#39;队伍&#39;;\n3.3 用户-队伍表 user_team3.1.1 字段阐释3.1.2 建表语句create table user_team\n(\n    id              bigint auto_increment               comment &#39;id&#39; primary key,\n    userId          bigint                              comment &#39;用户id&#39;,\n    teamId          bigint                              comment &#39;队伍id&#39;,\n    joinTime        datetime                            null comment &#39;加入时间&#39;,\n    createTime      datetime default CURRENT_TIMESTAMP  null comment &#39;创建时间&#39;,\n    updateTime      datetime default CURRENT_TIMESTAMP  null on update CURRENT_TIMESTAMP,\n    isDelete        tinyint  default 0                  not null comment &#39;是否删除&#39;\n)\n    comment &#39;用户队伍关系&#39;;\n两个关系：\n\n用户加了哪些队伍？\n队伍有哪些用户？\n\n方式：\n\n建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）\n用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）\n\n3.4 标签表（分类表）（并未选择）使用标签比分类更灵活。\n3.4.1 字段阐释\n\n\n\n字段\n名称\n类型\n作用\n\n\n\n\nid\n主键\nint\n\n\n\ntagName\n标签名\nvarchar\n非空（必须唯一，唯一索引）\n\n\nuserId\n上传标签的用户\nint\n如果要根据 userId 查已上传标签的话，最好加上，普通索引\n\n\nparentId\n父标签 id\nint\n查询所有标签，并且把标签分好组：按父标签 id 分组\n\n\nisParent\n是否为父标签\ntinyint\n0 - 不是父标签、1 - 父标签\n\n\ncreateTime\n创建时间\ndatetime\n\n\n\nupdateTime\n更新时间\ndatetime\n\n\n\nisDelete\n是否删除\ntinyint\n0、1\n\n\n\n\n3.4.2 建表语句create table tag\n(\n    id\t\t\tbigint auto_increment comment &#39;id&#39;  primary key,\n    tagName\t\tvarchar(256)\t\t\t\t\t\tnull comment &#39;标签名称&#39;,\n    userId\t\tbigint\t\t\t\t\t\t\t\tnull comment &#39;用户id&#39;,\n    parentId\tbigint\t\t\t\t\t\t\t\tnull comment &#39;父标签id&#39;,\n    isParent\ttinyint\t\t\t\t\t\t\t\tnull comment &#39;0 - 不是父标签，1 - 父标签&#39;,\n    createTime\tdatetime default CURRENT_TIMESTAMP\tnull comment &#39;创建时间&#39;,\n    updateTime\tdatetime default CURRENT_TIMESTAMP\tnull on update CURRENT_TIMESTAMP,\n    isDelete\ttinyint  default 0\t\t\t\t\tnot null comment &#39;是否删除&#39;,\n    constraint uniIdx_tagName unique (tagName)\n)\n    comment &#39;标签&#39;;\ncreate index idx_userId on tag (userId);\n3.5 查询方法由于数据量并不大仅为万级，故本项目选择第一种\n\n直接在用户表补充 tags 字段，[‘挑战杯’, ‘男’] 存 json 字符串  \n\n优点：查询方便、不用新建关联表，标签是用户的固有属性（除了该系统、其他系统可能要用到）节省开发成本\n查询用户列表，查关系表拿到这 100 个用户有的所有标签 id，再根据标签 id 去查标签表。\n哪怕性能低，可以用缓存。\n缺点：用户表多一列，会有冗余。\n\n\n加一个关联表，记录用户和标签的关系\n关联表的应用场景：查询灵活，可以正查反查\n缺点：要多建一个表、多维护一个表\n重点：企业大项目开发中尽量减少关联查询，很影响扩展性，而且会影响查询性能\n\n\n\n4 前端项目初始化4.1 前端引入用脚手架初始化项目\n\nVue CLI https://cli.vuejs.org/zh/\nVite 脚手架 ：https://vitejs.cn/guide/#scaffolding-your-first-vite-project\n\n整合组件库 Vant：\n\n安装 Vant npm i vant\n// Vant 2 按需引入 npm i vite-plugin-style-import@1.4.1 -D\nVant 3 按需引入插件 npm i unplugin-vue-components -D\n\n4.2 前端主页设计\n导航条：展示当前页面名称\n\n主页搜索框 =&gt; 搜索页 =&gt; 搜索结果页（标签筛选页）\n\n内容\n\ntab 栏：\n\n主页（推荐页 + 广告 ）\n\n搜索框\nbanner\n推荐信息流\n\n\n队伍页\n\n用户页（消息 - 暂时考虑发邮件）\n\n\n\n\n4.3 前端整合路由\nVue-Router：https://router.vuejs.org/zh/guide/#html，直接看官方文档引入\nVue-Router 根据不同的 url 来展示不同的页面（组件），不用自己写 if / else\n路由配置影响整个项目，建议单独用 config 目录、单独的配置文件去集中定义和管理。\n有些组件库可能自带了和 Vue-Router 的整合，所以尽量先看组件文档、省去自己写的时间。\n\n4.4 前端页面跳转传值\nquery =&gt; url searchParams，url 后附加参数，传递的值长度有限\nvuex（全局状态管理），搜索页将关键词塞到状态中，搜索结果页从状态取值\n\n4.5 前端不同页面传递数据\nurl querystring（xxx?id=1） 比较适用于页面跳转\nurl（/team/:id，xxx/1）\nhash (/team#1)\nlocalStorage\ncontext（全局变量，同页面或整个项目要访问公共变量）\n\n5 开发后端接口5.1 搜索标签\n允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%挑战杯%’ and like ‘%互联网+%’。\n允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%挑战杯%’ or like ‘%互联网+%’\n\n两种方式：\n\nSQL 查询（实现简单，可以通过拆分查询进一步优化）\n内存查询（灵活，可以通过并发进一步优化）\n\n\n如果参数可以分析，根据用户的参数去选择查询方式，比如标签数\n\n如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁。\n\n还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag\n\n可通过实际测试来分析哪种查询比较快，数据量大的时候验证效果更明显。\n5.2 解析 JSON 字符串\n序列化：java对象转成 json\n反序列化：把 json 转为 java 对象\n\njava  json 序列化库：\n\ngson（google 的）\n\nfastjson alibaba（ali 出品，快，但是漏洞太多）\n\njackson\n\nkryo\n\n\n5.2 用户中心整合用户中心（http://www.brandon777.com)来集中提供用户的检索、操作、注册、登录、鉴权\n\n前端整合路由\n前端开发（搜索页面、用户信息页、用户信息修改页）\n后端整合 Swagger + Knife4j 接口文档 \n存量用户信息导入及同步（爬虫或导入Excel）\n\n5.3 后端整合 Swagger + Knife4j 接口文档5.3.1 接口文档说明什么是接口文档？写接口信息的文档，每条接口包括：\n\n请求参数\n响应参数\n错误码\n\n\n接口地址\n接口名称\n请求类型\n请求格式\n备注\n\n5.3.2 接口文档作用\n有个书面内容（背书或者归档），便于大家参考和查阅，便于 沉淀和维护 ，拒绝口口相传\n接口文档便于前端和后端开发对接，前后端联调的 介质 。后端 =&gt; 接口文档 &lt;= 前端\n好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发测试效率\n\n5.3.3 接口文档实现\n手写（比如腾讯文档、Markdown 笔记）\n自动化接口文档生成：自动根据项目代码生成完整的文档或在线调试的网页。Swagger，Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国产）\n\n5.3.4 接口文档技巧Swagger 原理：\n\n引入依赖（Swagger 或 Knife4j：https://doc.xiaominfo.com/knife4j/documentation/get_start.html）\n自定义 Swagger 配置类\n定义需要生成接口文档的代码位置（Controller）\n千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 @Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;) 限定配置仅在部分环境开启\n启动即可\n可以通过在 controller 方法上添加 @Api、@ApiImplicitParam(name = “name”,value = “姓名”,required = true)    @ApiOperation(value = “向客人问好”) 等注解来自定义生成的接口描述信息\n\n如果 springboot version &gt;= 2.6，需要添加如下配置：\nspring:\n  mvc:\n  \tpathmatch:\n      matching-strategy: ANT_PATH_MATCHER\n5.4 模拟教务学生信息\n从 excel 中导入全量用户数据，判重 。 easy excel：https://alibaba-easyexcel.github.io/index.html\n抓取写了自我介绍的同学信息，提取出用户昵称、用户唯一 id、自我介绍信息\n从自我介绍中提取信息，然后写入到数据库中\n\nEasy Excel\n两种读对象的方式：\n\n确定表头：建立对象，和表头形成映射关系\n不确定表头：每一行数据映射为 Map\n\n两种读取模式：\n\n监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。\n同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。\n\n6 Session 共享\n单机登录改为分布式 session 登录。\n种 session 的时候注意范围，cookie.domain\n比如两个域名：\naaa.brandon777.com\nbbb.brandon777.com\n\n\n如果要共享 cookie，可以种一个更高层的公共域名，比如 brandon777.com\n\n6.1 Session 共享存储\n服务器 A 登录后，请求发到服务器 B，不认识该用户。\n用户在 A 登录，所以 session（用户登录信息）存在了 A 上\n结果请求 B 时，B 没有用户信息，所以不认识。\n\n\n\n解决方案：共享存储 ，而不是把数据放到单台服务器的内存中\n\n\n6.2 Session 共享实现6.2.1 原理如何共享存储？\n\nRedis（基于内存的 K / V 数据库）此处选择 Redis，因为用户信息读取 / 是否登录的判断极其频繁 ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w\nMySQL \n文件服务器 ceph\n\n6.2.2 实现\n安装 Redis\n官网：https://redis.io/\nredis 管理工具 quick redis：https://quick123.net/\n\n\n\n引入 redis，能够操作 redis：\n\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-data-redis --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：\n\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.session&#x2F;spring-session-data-redis --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n修改 spring-session 存储配置 spring.session.store-type\n默认是 none，表示存储在单台服务器\nstore-type: redis，表示从 redis 读写 session\n\n\n\nJWT 的优缺点：https://zhuanlan.zhihu.com/p/108999941\n\n7 主页开发\n最简单：直接 list 列表\n模拟 100 万个用户，再去查询\n\n7.1 导入数据\n用可视化界面：适合一次性导入、数据量可控\n\n写程序：for 循环，分批写入（可以用接口来控制）要保证可控、幂等，注意线上环境和测试环境是有区别的\n导入 1000 万条，for i 100w\n\n执行 SQL 语句：适用于小数据量\n\n\n7.2 编写一次性任务for 循环插入数据的问题：\n\n建立和释放数据库链接（批量查询解决）\nfor 循环是绝对线性的（并发）\n\n\n并发要注意执行的先后顺序无所谓，不要用到非并发类的集合\n\nprivate ExecutorService executorService &#x3D; new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(10000));\n&#x2F;&#x2F; CPU 密集型：分配的核心线程数 &#x3D; CPU - 1\n&#x2F;&#x2F; IO 密集型：分配的核心线程数可以大于 CPU 核数\n\n数据库慢可预先把数据查出来，放到一个更快读取的地方，不用再查数据库了。（缓存）\n预加载缓存，定时更新缓存。（定时任务）\n分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了\n\n8 数据查询慢-缓存用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快地读写。\n8.1 缓存的实现\nRedis（分布式缓存）\nmemcached（分布式）\nEtcd（云原生架构的一个分布式存储，存储配置，扩容能力）\n\n\n\nehcache（单机）\n\n本地缓存（Java 内存 Map）\n\nCaffeine（Java 内存缓存，高性能）\nGoogle Guava\n\n8.2 Redis\n\n\n\n\n\n\n\n\nNoSQL 数据库\n\nkey - value 存储系统（区别于 MySQL，他存储的是键值对）\n\n8.2.1 Redis 数据结构\nString 字符串类型： name: “Brandon”\nList 列表：names: [“Brandon”, “Sarbr”, “Brandon”]\nSet 集合：names: [“Brandon”, “Sarbr”]（值不能重复）\nHash 哈希：nameAge: {  “Brandon”: 1, “Sarbr”: 2 }\nZset 集合：names: {  Brandon- 9,   Sarbr- 12  }（适合做排行榜）\n\n\n\nbloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）\ngeo（计算地理位置）\nhyperloglog（pv / uv）\npub / sub（发布订阅，类似消息队列）\nBitMap （1001010101010101010101010101）\n\n8.2.2 自定义序列化package com.brandon.kunjing.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.RedisSerializer;\n\n@Configuration\npublic class RedisTemplateConfig &#123;\n\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;\n        RedisTemplate&lt;String, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;();\n        redisTemplate.setConnectionFactory(connectionFactory);\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        return redisTemplate;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n引入一个库时，先写测试类\n8.3 Java 里的实现方式8.3.1 Spring Data Redis（推荐）Spring Data：通用的数据访问框架，定义了一组 增删改查 的接口\nmysql、redis、jpa\nspring-data-redis\n1）引入\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n2）配置 Redis 地址\nspring:\n  # redis 配置\n  redis:\n    port: 6379\n    host: localhost\n    database: 0\n8.3.2 Jedis\n独立于 Spring 操作 Redis 的 Java 客户端\n要配合 Jedis Pool 使用\n\n8.3.3 Lettuce\n高阶 的操作 Redis 的 Java 客户端\n异步、连接池\n\n8.3.4 Redisson\n分布式操作 Redis 的 Java 客户端，像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）\n\n8.3.5 JetCache对比\n\n如果项目用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便\n如果项目用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool\n如果项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池\n\n8.4 设计缓存 key\n不同用户看到的数据不同\nsystemId:moduleId:func:options（不要和别人冲突）\nkunjing:user:recommed:userId\n\nredis 内存不能无限增加，一定要设置过期时间。\n8.5 缓存预热问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库\n8.5.1 优缺点\n缓存预热的优点：\n\n解决上面的问题，可以让用户始终访问很快\n\n\n\n\n缺点：\n\n增加开发成本（你要额外的开发、设计）\n预热的时机和时间如果错了，有可能你缓存的数据不对或者太老\n需要占用额外空间\n\n\n\n8.5.2 缓存预热\n定时\n模拟触发（手动触发）\n\n8.5.3 实现\n用定时任务，每天刷新所有用户的推荐列表\n注意点：\n缓存预热的意义（新增少、总用户多）\n缓存的空间不能太大，要预留给其他缓存空间\n缓存数据的周期（此处每天一次）\n\n\n\n9 缓存预热—定时任务\nSpring Scheduler（spring boot 默认整合了） \nQuartz（独立于 Spring 存在的定时任务框架）\nXXL-Job 之类的分布式任务调度平台（界面 + sdk）\n\n\n第一种方式：\n\n主类开启 @EnableScheduling\n给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率\n\n\n\n\n不必背 cron 表达式。\nhttps://cron.qqe2.com/\nhttps://www.matools.com/crontab/\n\n\n9.1 控制定时任务的执行\n浪费资源，想象 10000 台服务器同时 “打鸣”\n脏数据，比如重复插入\n\n\n要控制定时任务在同一时间只有 1 个服务器能执行。\n\n\n分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大\n\n写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低；但是我们的 IP 可能是不固定的，把 IP 写的太死了\n\n动态配置，配置是可以轻松的、很方便地更新的（代码无需重启），但是只有 ip 符合配置的服务器才真实执行业务逻辑。\n\n数据库\nRedis\n配置中心（Nacos、Apollo、Spring Cloud Config）\n\n问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改\n\n分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。\n\n\n\n单机就会存在单点故障。\n\n10 控制定时任务—锁\n有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。\nJava 实现锁：synchronized 关键字、并发包的类\n问题：只对单个 JVM 有效\n\n10.1 分布式锁\n有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。\n单个锁只对单个 JVM 有效\n\n10.2 分布式锁实现的关键10.2.1 抢锁机制\n保证同一时间只有 1 个服务器能抢到锁 核心思想 ：\n先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。\n等先来的人执行方法结束，把标识清空，其他的人继续抢锁。\n\n\nMySQL 数据库：select for update 行级锁（最简单）（乐观锁）\nRedis 实现：内存数据库，读写速度快 。支持 setnx、lua 脚本，比较方便我们实现分布式锁。\nsetnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false\n\n\n\n10.2.2 注意事项\n用完锁要释放（腾地方）√\n\n锁一定要加过期时间 √\n\n如果方法执行时间过长，锁提前过期了？\n问题：\n\n连锁效应：释放掉别人的锁\n这样还是会存在多个方法同时执行的情况\n\n\n\n​    解决方案：续期\nboolean end &#x3D; false;\n\nnew Thread(() -&gt; &#123;\n    if (!end)&#125;&#123;\n    续期\n&#125;)\n\nend &#x3D; true;\n\n\n释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁\n&#x2F;&#x2F; 原子操作\nif(get lock &#x3D;&#x3D; A) &#123;\n    &#x2F;&#x2F; set lock B\n    del lock\n&#125;\nRedis + lua 脚本实现\n\nRedis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？\n\n\nhttps://blog.csdn.net/feiying0canglang/article/details/113258494\n10.3 Redisson 实现分布式锁\nJava 客户端，数据网格\n实现了很多 Java 里支持的接口和数据结构\nRedisson 是一个 java 操作 Redis 的客户端，提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。\n\n10.3.1 2 种引入方式\nspring boot starter 引入（不推荐，版本迭代太快，容易冲突）https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter\n直接引入：https://github.com/redisson/redisson#quick-start\n\n示例代码&#x2F;&#x2F; list，数据存在本地 JVM 内存中\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;Brandon&quot;);\nSystem.out.println(&quot;list:&quot; + list.get(0));\n\nlist.remove(0);\n\n&#x2F;&#x2F; 数据存在 redis 的内存中\nRList&lt;String&gt; rList &#x3D; redissonClient.getList(&quot;test-list&quot;);\nrList.add(&quot;Brandon&quot;);\nSystem.out.println(&quot;rlist:&quot; + rList.get(0));\nrList.remove(0);\n10.4 定时任务  + 锁\nwaitTime 设置为 0，只抢一次，抢不到就放弃\n注意释放锁要写在 finally 中\n\n10.4.1 实现代码void testWatchDog() &#123;\n    RLock lock &#x3D; redissonClient.getLock(&quot;kunjing:precachejob:docache:lock&quot;);\n    try &#123;\n        &#x2F;&#x2F; 只有一个线程能获取到锁\n        if (lock.tryLock(0, -1, TimeUnit.MILLISECONDS)) &#123;\n            &#x2F;&#x2F; todo 实际要执行的方法\n            doSomeThings();\n            System.out.println(&quot;getLock: &quot; + Thread.currentThread().getId());\n        &#125;\n    &#125; catch (InterruptedException e) &#123;\n        System.out.println(e.getMessage());\n    &#125; finally &#123;\n        &#x2F;&#x2F; 只能释放自己的锁\n        if (lock.isHeldByCurrentThread()) &#123;\n            System.out.println(&quot;unLock: &quot; + Thread.currentThread().getId());\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n10.4.2 看门狗机制\n\n\n\n\n\n\n\n\nredisson 中提供的续期机制\n开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。\n原理：\n\n监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）\n如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期\n\nhttps://blog.csdn.net/qq_26222859/article/details/79645203\n\nZookeeper 实现（不推荐）\n11 组队功能11.1 理想的应用场景和别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍。\n11.2 需求分析\n用户可以 创建 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0\n\n\n\n\n\n\n\n\n\n\n队长、剩余的人数\n聊天？\n公开 或 private 或加密\n用户创建队伍最多 5 个\n\n展示队伍列表，根据名称搜索队伍  P0，信息流中不展示已过期的队伍\n\n\n修改队伍信息 P0 ~ P1\n\n\n用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限  P0\n\n\n\n\n\n\n\n\n\n\n是否需要队长同意？筛选审批？\n\n用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 —— 先来后到） P1\n\n\n队长可以解散队伍 P0\n\n\n\n分享队伍 =》 邀请其他用户加入队伍 P1\n\n\n业务流程：\n\n生成分享链接（分享二维码）\n用户访问链接，可以点击加入\n\n\n队伍人满后发送消息通知 P1\n\n\n11.3 系统（接口）设计11.3.1 创建队伍用户可以 创建 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0\n\n\n\n\n\n\n\n\n\n队长、剩余的人数\n聊天？\n公开 或 private 或加密\n信息流中不展示已过期的队伍\n\n请求参数是否为空？\n是否登录，未登录不允许创建\n校验信息\n队伍人数 &gt; 1 且 &lt;= 20\n队伍标题 &lt;= 20\n描述 &lt;= 512\nstatus 是否公开（int）不传默认为 0（公开）\n如果 status 是加密状态，一定要有密码，且密码 &lt;= 32\n超时时间 &gt; 当前时间\n校验用户最多创建 5 个队伍\n\n\n插入队伍信息到队伍表\n插入用户  =&gt; 队伍关系到关系表\n\n11.3.2 查询队伍列表分页展示队伍列表，根据名称、最大人数等搜索队伍  P0，信息流中不展示已过期的队伍\n\n从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件\n不展示已过期的队伍（根据过期时间筛选）\n可以通过某个关键词同时对名称和描述查询\n只有管理员才能查看加密还有非公开的房间\n关联查询已加入队伍的用户信息\n关联查询已加入队伍的用户信息（可能会很耗费性能，建议大家用自己写 SQL 的方式实现）\n\n实现方式\n1）自己写 SQL\n&#x2F;&#x2F; 1. 自己写 SQL\n&#x2F;&#x2F; 查询队伍和创建人的信息\nselect * from team t left join user u on t.userId &#x3D; u.id\n&#x2F;&#x2F; 查询队伍和已加入队伍成员的信息\nselect *\nfrom team t\n       left join user_team ut on t.id &#x3D; ut.teamId\n       left join user u on ut.userId &#x3D; u.id;\n11.3.3 修改队伍信息\n判断请求参数是否为空\n查询队伍是否存在\n只有管理员或者队伍的创建者可以修改\n如果用户传入的新值和老值一致，就不用 update 了（可自行实现，降低数据库使用次数）\n如果队伍状态改为加密，必须要有密码\n更新成功\n\n11.3.4 用户可以加入队伍其他人、未满、未过期，允许加入多个队伍，但是要有个上限  P0\n\n用户最多加入 5 个队伍\n队伍必须存在，只能加入未满、未过期的队伍\n不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）\n禁止加入私有的队伍\n如果加入的队伍是加密的，必须密码匹配才可以\n新增队伍 - 用户关联信息\n\n11.3.5 用户可以退出队伍请求参数：队伍 id\n\n校验请求参数\n\n校验队伍是否存在\n\n校验我是否已加入队伍\n\n如果队伍\n\n只剩一人，队伍解散\n\n还有其他人\n\n如果是队长退出队伍，权限转移给第二早加入的用户 —— 先来后到\n\n\n\n\n\n\n\n\n\n只用取 id 最小的 2 条数据\n\n非队长，自己退出队伍\n\n\n\n\n\n\n11.3.6 队长可以解散队伍请求参数：队伍 id\n业务流程：\n\n校验请求参数\n校验队伍是否存在\n校验你是不是队伍的队长\n移除所有加入队伍的关联信息\n删除队伍\n\n11.4 事务注解@Transactional(rollbackFor = Exception.class)\n事务回滚，要么数据操作都成功，要么都失败。\n11.5 请求参数包装类\n请求参数名称 / 类型和实体类不一样\n\n有一些参数用不到，如果要自动生成接口文档，会增加理解成本\n\n对个实体类映射到同一个对象\n\n\n11.5.1 包装类作用\n可能有些字段需要隐藏，不能返回给前端\n\n\n或者有些字段某些方法是不关心的\n\n11.6 数据查询可分表\nmycat、sharding sphere 框架\n一致性 hash\n\n11.7 队伍操作权限控制\n加入队伍： 仅非队伍创建人、且未加入队伍的人可见\n更新队伍：仅创建人可见\n解散队伍：仅创建人可见\n退出队伍：创建人不可见，仅已加入队伍的人可见\n\n12 随机匹配更快地匹配自己兴趣相同的队友\n12.1 匹配原理\n匹配多个，并且按照匹配的相似度从高到低排序、\n根据标签 tags 匹配\n还可以根据 user_team 匹配加入相同队伍的用户\n\n\n\n\n\n\n\n\n\n\n本质：找到有相似标签的用户\n举例：\n用户 A：[Java, 大一, 男]\n用户 B：[Java, 大二, 男]\n用户 C：[Python, 大二, 女]\n用户 D：[Java, 大一, 女]\n\n找到有共同标签最多的用户（TopN）\n共同标签越多，分数越高，越排在前面\n如果没有匹配的用户，随机推荐几个（降级方案）\n\n12.2 匹配算法编辑距离算法：https://blog.csdn.net/DBC_121/article/details/104198838\n\n\n\n\n\n\n\n\n\n最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2\n余弦相似度算法：https://blog.csdn.net/m0_55613022/article/details/125683937（如果需要带权重计算，比如学什么方向最重要，性别相对次要）\n12.3 匹配实现\n直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）\n\n优化方法：\n\n切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒）\n\nMap 存了所有的分数信息，占用内存\n解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）\ne.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了\n\n细节：剔除自己 √\n\n尽量只查需要的数据：\n\n过滤掉标签为空的用户 √\n根据部分标签取用户（前提是能区分出来哪个标签比较重要）\n只查需要的数据（比如 id 和 tags） √（7.0s）\n\n\n提前查？（定时任务）\n\n提前把所有用户给缓存（不适用于经常更新的数据）\n提前运算出来结果，缓存（针对一些重点用户，提前缓存）\n\n\n\n\n大数据推荐不需要查出所有用户及相似度。\n检索 =&gt; 召回 =&gt; 粗排 =&gt; 精排 =&gt; 重排序等等。\n\n检索：尽可能多地查符合要求的数据（比如按记录查）\n召回：查询可能要用到的数据（不做运算）\n粗排：粗略排序，简单地运算（运算相对轻量）\n精排：精细排序，确定固定排位\n\n\n\n13 遇到问题及解决\n组件化思想：很多页面要复用组件 / 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）\n查询所有标签并分组：按父标签 id 分组\n根据父标签查询子标签：根据 id 查询\n内存查询与数据库查询优化\n优化主页性能：缓存 + 定时任务 + 分布式锁\n缓存 + 锁用完释放、设置过期时间\n前端加载骨架屏特效：van-skeleton 组件\n仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态）\n前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）\n在后端去做上述事情（推荐）\n\n\n前端导航栏死【标题】问题：使用 router.beforeEach，根据要跳转页面的 url 路径 匹配 config/routes 配置的 title 字段。\n强制登录，前端全局响应拦截，自动跳转到登录页\n加入有密码的房间，要指定密码\n分布式锁 导致的其他服务器数据不统一的问题或者多个 Redis 里的数据不一致。\n重复加入队伍的问题（加锁、分布式锁）并发请求时可能出现问题\n用户登录页跳转\n标签\n前端拦截器统一输出日志\n\n\nVant3 更新后配置 viteconfig 需要 npm 按需引入插件了，styleImport 变成了 Component，resolve 变成了 resolver，vite3 更新后还得单独引入 css，感觉越变越麻烦但确实降低了冗余\n\n\n项目初始化不小心混合了 Vant2 和 Vant3 unplugin-vue-components 再手动引入组件样式的按需引入插件和样式\n\n导入 Swagger + Knife4j 出现版本冲突，yml 开始没解析 ant_patch_matcher 也许有缓存\n\n\n\n\n\nmvnrepository中easyexcel3.1.0版本用不了了，idea2022.2database没有了\n\n共模拟1000000条数据，插入1000条3s，顺序执行批量导入0.8s，100000条17s，并发100000条10组5s ，20组、40组5s性能几乎无变化，可能与线程切换需要时间、数据库性能、CPU核数（CPU密集型线程数CPU核数-1，IO密集型线程数可以大于CPU核数）有关，不同情况需具体测试。\n\n\n\n\n\n\n\nredis timeout MILLISECONDS写成MICROSECONDS\n\n\n\nlombok只要改个pom就会找不到符号，找不到方法，勾选enable annotation processing基本没用，setting里build，compiler对VM options加上-Djs.track.ap.dependencies=false好用\n\n两个Long封装类不能用!=，最后抽离出两个变量转为long基本类型却可以使用!=。可能 Java 更新后 ==比较栈（内存中地址值），equals比较堆（两个对象的内容） \n\n\n\n\n\n\n前后端联调CORS协议现在CROSSORIGIN配置跨域还要配置安全证书(allowCredentials=true) \n\nWebStorm打包ts的时避免报错可以file，setting，file watcher配置Typescript，有的加的// @ts-ignore，有的加的any类型，或者给自己定义的.d.ts加上了变量，ts.config里面strict可以改成false。\n\n部署上线记得改前后端URL域名，端口。 \n\n\n","slug":"Kun Jing","date":"2022-10-05T09:01:36.000Z","categories_index":"Project","tags_index":"Project","author_index":"Brandon"},{"id":"d47a36c3a510133b5b347d3a187e7783","title":"Opertion System Outline","content":"0 前言0.1 前言\n基本概念、基本方法\n设计原理、实现方法\n形成、类型、功能\n进程管理、存储器管理、设备管理、文件管理\n网络操作系统、分布式操作系统\n\n0.2 内容\n背景知识\n\n基本概念、发展、特性、功能和结构设计\n硬件环境\n\n\n进程\n进程和线程的\n\n基本概念\n进程控制\n进程调度\n进程同步\n进程通信\n死锁\n\n\n存储管理\n\n概念和功能\n分区和页式存储管理\n虚拟页式存储器管理\n\n\n文件和输入/输出管理\n\n操作系统的用户接口管理\n文件管理的基本概念和功能\n设备管理的基本概念和功能\n\n\n网络与分布式系统\n\n网络操作系统\n分布式操作系统\n\n\n\n1 引论1.1 操作系统的概念\n计算机系统\n硬件（子）系统、软件（子）系统\n计算机系统的层次结构\n软件分类\n系统软件\n支撑软件\n应用软件\n\n\n\n\n操作系统简介\n操作系统的地位\n操作系统的定义\n操作系统的目标\n\n\n\n1.2 操作系统的形成与发展\n操作系统的形成\n单道批处理系统\n多道批处理系统\n分时系统\n实时系统\n操作系统的\n推动操作系统\n\n1.3 研究操作系统的几种观点\n软件的观点\n计算机系统资源管理的观点\n进程的观点\n用户与计算机硬件系统之间接口的观点\n虚拟机器观点\n服务提供者观点\n\n1.4 操作系统的功能与特征\n通用操作系统\n操作系统的功能\n处理机、存储器、设备、文件、用户接口\n\n\n操作系统的特征\n并发、共享、虚拟、异步性\n\n\n\n1.5 操作系统结构设计\n传统的操作系统结构\n模块化结构\n层次结构\n\n\n现代的操作系统结构\n微内核\n客户机 / 服务器模式\n\n\n\n2 操作系统的硬件环境2.1 中央处理机（CPU）\nCPU的构成与基本工作方式\n特权指令与非特权指令\n处理机的状态\n程序状态字PSW\n\n2.2 存储系统\n存储器类型\n存储器层次结构\n存储分块\n存储保护\n\n2.3 缓冲技术与中断技术\n缓冲技术\n中断技术\n概念\n分类\n组成部分\n基本功能\n中断逻辑与中断寄存器\n多级中断和中断屏蔽\n中断响应\n中断处理\n时钟\n\n\n\n3 进程与进程管理3.1 进程引入\n前趋图\n程序顺序执行\n程序并发执行\n多道程序设计\n必须解决的问题\n\n3.2 进程\n引入进程原因\n进程概念\n进程的基本状态和转换\n\n\n\n进程控制块PCB\n进程控制\n\n3.3 进程调度\n调度的基本概念\n功能\n调度方式\n\n\n进程调度算法\n先进先出（FIFO）算法\n最短处理机运行期优先调度算法\n最高响应比优先调度算法\n优先级调度算法\n时间片轮转调度算法\n前后台调度算法\n多级反馈队列轮转算法\n\n\n进程调度的时间和过程\n\n3.4 线程的基本概念\n线程的引入\n线程的定义和属性\n线程与进程的比较\n线程的实现机制\n用户级线程\n内核支持线程\n用户级和内核支持比较\n\n\n\n4 进程同步与通信4.1 进程间的相互作用\n进程间联系\n临界资源\n临界区\n同步机制应遵循的原则：空闲让进、忙则等待、优先等待、让权等待\n\n\n利用软件方法解决进程互斥问题\n利用硬件方法解决进程互斥问题\nTest-and-Set指令\nSwap指令\n\n\n信号量机制\n记录型：wait、signal\nAND型：swait、ssignal\n一般“信号量集”机制\n\n\n经典进程同步问题\n生产者-消费者问题\n读者-写者问题\n哲学家进餐问题\n嗜睡的理发师问题\n\n\n管程机制\n\n4.2 进程通信\n基本概念\n进程通信的类型\n共享存储器系统\n消息传递系统\n管道通信\n\n\n直接通信和间接通信\n消息缓冲队列\n\n4.3 死锁\n产生死锁的四个必要条件\n互斥条件\n请求和保持条件\n不剥夺条件\n环路等待条件\n\n\n预防死锁\n摒弃“请求和保持”条件\n摒弃“不剥夺”条件\n摒弃“环路等待”条件\n\n\n避免死锁\n安全与不安全状态\n银行家算法\n安全性算法\n\n\n检测死锁\n资源分配图\n死锁定理\n死锁检测中的数据结构\n\n\n解除死锁\n\n5 存储器管理5.1 概述\n存储体系\n存储管理目的\n存储管理任务\n程序的链接和装入\n各种存储管理方式\n\n5.2 连续存储管理方式\n单一连续分配\n分区分配\n固定分区\n可变分区\n\n\n\n5.3 覆盖技术与交换技术\n覆盖技术\n交换技术\n\n5.4 分页存储管理方式\n工作原理\n动态地址变换\n快表\n两级和多级页表\n分配与回收\n\n5.5 分段存储管理方式\n基本思想（工作原理）\n动态地址变换\n分页和分段的主要区别\n\n5.6 段页式存储管理方式\n基本原理\n地址变换\n\n6 虚拟存储器管理6.1 概述\n局部性原理\n虚拟存储器特征\n虚拟存储器定义\n\n6.2 分页虚拟存储管理\n基本原理\n缺页中断结构\n地址变换结构\n页面置换算法\n内存分配策略和分配算法\n最小物理块数\n物理块的分配策略\n物理块分配算法\n调页策略\n\n\n抖动问题\n\n6.3 分段虚拟存储管理\n基本原理\n缺段中断结构\n段的动态链接\n段的共享\n\n7 用户接口管理7.1 概述\n命令接口\n程序接口\n图形接口\n\n7.2 命令接口\n联机命令接口\n命令的格式和分类\n终端处理程序\n命令解释程序\n\n\n脱机命令接口\n\n7.3 系统调用\n概念\n系统调用分类\n系统调用与一般过程调用的区别\n\n\n处理过程\n基本概念\n系统调用的执行过程大体上分成以下三步\n\n\n\n8 文件管理8.1 概述\n文件和文件系统\n文件的分类\n\n8.2 文件的结构和存取方式\n文件的存取方式\n文件的逻辑结构\n存储介质\n文件的物理结构\n\n8.3 文件目录\n文件目录管理应达到的要求\n文件控制块\n文件目录结构\n目录查找和改进\n\n8.4 文件系统的实现\n打开文件表\n外存空间管理\n\n8.5 文件的使用\n主要操作\n文件共享\n\n8.6 文件系统的安全性和数据一致性\n影响文件安全性主要因素\n防止人为因素造成的文件不安全性\n隐蔽文件和目录\n口令\n文件加密\n制定访问权限\n\n\n防止系统因素或自然因素造成的文件不安全性\n坏块管理\n磁盘容错技术\n备份\n\n\n文件系统的数据一致性\n块的一致性检查\n文件一致性检查\n\n\n\n8.7 磁盘调度\n先来先服务（FCFS）算法\n最短查找时间优先（SSTF）算法\n扫描算法\n电梯调度算法\n循环扫描策略\nN步扫描策略\nFSCAN算法\n\n\n磁盘的优化分布\n\n8.8 Linux 文件系统\nLinux 文件系统结构\nLinux 文件类型\nLinux 文件系统目录\nLinux 文件查找\nLinux 文件操作\nLinux 文件共享\nLinux 文件目录操作\nLinux 文件一致性处理\nLinux EXT2 文件系统\nEXT2 位示图和 I 节点图\nLinux 高速缓存\n\n9 设备管理9.1 概述\n设备的分类\n\n设备管理目标\n\n设备管理任务\n\n监视所有设备的状态\n\n\n\n制定设备分配策略\n设备的分配\n设备的回收\n\n\n\n9.2 I/O硬件特点\n设备组成\n设备接口\n设备控制器\n通道\nI/O 控制方式\n缓冲技术\n缓冲池\n\n9.3 I/O软件组成\nI/O 软件目标\n中断处理程序\n设备驱动程序\n独立于设备的软件\n用户空间的 I/O 软件\n\n9.4 设备分配\n设备分配中的数据结构\n设备独立性\n设备分配\n\n9.5 虚拟设备\nSpooling 技术\n共享打印机\n\n10 网络服务器与分布式系统10.1 分布式系统概述\n分布式能力\n\n通信结构\n\n开放式系统互连通信结构\nOSI七层模型\n\n物理层\n数据链路层\n网络层\n传输层\n会话层\n表示层\n应用层\n\n\n\n10.2 网络服务器\n服务器结构\n磁盘和文件服务器\n文件服务器\n磁盘服务器\n打印机服务器\n调制解调器服务器\n\n\n\n10.3 分布式进程管理\n分布式互斥\n集中式算法\n分布式算法\n克服时钟同步困难：事件定序法\n\n\n分布式算法\nLamport 分布式算法\n令牌传递法\n\n\n\n10.4 进程迁移\n进程迁移\n进程迁移机制\n迁移处理\n\n10.5 分布式进程通信\n信息传送机制\n远程过程调用\n确定分布式系统的全局状态\n全局状态和分布式瞬态\n分布式瞬态算法\n\n\n\n10.6 分布式进程同步与互斥\n事件定序法\n\n集中式算法\n\n分布式算法\n\n\nLamport 分布式算法\n\n\n令牌传递法\n\n\n10.7 分布式进程死锁问题\n资源分配中的死锁\n死锁的预防\n死锁的检测\n系统是集中式的控制\n分层控制\n分布式控制\n\n\n\n\n消息通信中的死锁\n相互等待\n消息死锁和资源死锁的区别\n破坏死锁方法：预防或检测\n\n\n没有空闲可用的消息缓冲区\n直接存储转发死锁\n间接存储转发死锁\n\n\n\n\n\n","slug":"Operation System Outline","date":"2022-10-03T09:01:36.000Z","categories_index":"Opertion System","tags_index":"Opertion System","author_index":"Brandon"},{"id":"6c60290e7688a2cab83459ffd68eb546","title":"1 计算机系统概论","content":"0 导读 脉冲信号\n\n\n\n\n\n1 计算机的分类1.1 电子计算机\n电子模拟计算机\n“模拟”就是相似的意思。模拟计算机的特点是数值由连续量来表示，运算过程也是连续的。\n\n电子数字计算机\n它是在算盘的基础上发展起来的，是用数目字来表示数量的大小。数字计算机的主要特点是按位运算，并且不连续地跳动计算。\n\n\n\n\n\n\n\n数字计算机\n模拟计算机\n\n\n\n\n数据表示方式\n数字 0/1\n电压\n\n\n计算方式\n数字计数\n电压组合和测量值\n\n\n控制方式\n程序控制\n盘上连线\n\n\n精度\n高\n低\n\n\n数据存储量\n大\n小\n\n\n逻辑判断能力\n强\n无\n\n\n\n\n1.2 数字计算机​        数字计算机根据计算机的效率、速度、价格、运行的经济性和适应性来划分，可以划分为两类：\n\n专用计算机\n专用机是最有效、最经济和最快速的计算机，但是它的适应性很差。\n\n通用计算机\n通用计算机适应性很大，但是牺牲了效率、速度和经济性。\n\n\n1.3 通用计算机​    通用计算机根据体积、简易性、功率损耗、性能指标、数据存储容量、指令规模和机器价格等可以分为：\n\n超级计算机\n大型机\n服务器\nPC机\n单片机\n多核机\n\n\n2 计算机发展简史2.1 计算机的五代变化\n第一代1946-1957年，电子管计算机：数据处理\n第二代1958-1964年，晶体管计算机：工业控制\n第三代1965-1971年，中小规模集成电路计算机：小型计算机\n第四代1972-1990年，大规模和超大规模集成电路计算机：微型计算机\n第五代1991年-至今，巨大规模集成电路计算机：单片机\n\n2.2 半导体存储器的发展\n20世纪50~60年代，所有计算机存储器都是由微小的铁磁体环\n\n1970年，仙童半导体公司生产出了第一个较大容量半导体存储器\n\n从1970年起，半导体存储器经历了11代：单个芯片\n1KB，4KB，16KB，64KB，256KB，1MB，4MB，16MB，64MB，256MB，GB\n\n其中 $1K=2^{10}$，$1M=2^{20}$，$1G=2^{30}$\n\n\n2.3 微处理器的发展\n1971年 Intel 公司开发出 Intel 4004。这是第一个将 CPU 的所有元件都放入同一块芯片内的产品，于是，微处理器诞生了。\n微处理器演变中的另一个主要进步是1972年出现的 Intel 8008，这是第一个8位微处理器，它比 4004 复杂一倍。\n1974年出现了 Intel 8080。这是第一个通用微处理器，而 4004 和 8008 是为特殊用途而设计的。8080 是为通用微机而设计的中央处理器。\n20世纪70年代末才出现强大的通用16位微处理器，8086便是其中之一。\n这一发展趋势中的另一阶段是在1981年，贝尔实验室和HP公司开发出了32位单片微处理器。\nIntel 于1985年推出了32位微处理器 Intel 80386。\n到现在的64位处理器和多核处理器\n\n2.4 计算机的性能指标\n吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S)。\n\n响应时间：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（$10^{-6}S$）、纳秒（$10^{-9}S$）。\n\n利用率：表示在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。\n\n处理机字长：指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。\n字长越长，表示计算的精度越高。\n\n总线宽度：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。\n\n存储器容量：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。\n其中 $K=2^{10}$，$M=2^{20}$，$G=2^{30}$，$T=2^{40}$，$B=8$ 位（1个字节）。\n存储器容量越大，记忆的二进制数越多。\n\n存储器带宽：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。\n\n主频：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（$f$）叫CPU的主频。\n度量单位是MHz（兆赫兹）、GHz（吉赫兹）。例如 Pentium 系列机为60MHz~266MHz，而 Pentium 4 升至3.6GHz。\n\n时钟周期：主频的倒数（$T$），即 $T=\\frac{1}{f}$，度量单位是微秒、纳秒。\n\nCPU执行时间：表示CPU执行一段程序所占用的CPU时间，可用下式计算：\n\nCPU执行时间=CPU时钟周期数\\times CPU时钟周期长\nCPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数。用下式计算：\n\nCPI=\\frac{执行某段程序所需的CPU时钟周期数}{该程序包含的指令条数}\nMIPS：表示每秒百万条指令数，用下式计算：\n\nMIPS=\\frac{指令条数}{程序执行时间\\times10^6}=\\frac{时钟频率}{CPI\\times10^6}MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。\n\nTe：程序执行时间，用下式计算：\n\nTe=\\frac{指令条数}{MIPS\\times10^6}\nMFLOPS：表示每秒百万次浮点操作次数，用下式计算：\n\nMFLOPS=\\frac{程序中的浮点操作次数}{程序执行时间\\times10^6}MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。\n\nTFLOPS：表示每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。\n\n\n\n\n3 计算机的硬件3.1 硬件组成要素\n\n\n\n\n\n\n\n\n通过一个例子了解数字计算机的主要组成和工作原理。\n\n用一个算盘、一张带有横格的纸和一支笔，要求我们计算 $y=ax+b-c$ 这样一个题目。\n解题步骤和数据记录在横格纸上。\n\n3.1.1 手工模仿计算机工作\n3.1.2 数字计算机基本组成\n控制器：人的大脑的操作控制功能\n运算器：人的大脑的计算功能\n存储器：人的大脑记忆功能\n输入设备：交互接口，笔\n输出设备：交互接口：纸\n\n3.1.3 冯·诺依曼型计算机\n存储程序\n按地址自动执行\n五大部件：包括控制器、运算器、存储器、输入设备、输出设备\n以运算器为中心\n\n\n3.1.4 现代计算机的体系结构\n现代的计算机已转为以存储器为中心。\n\n\n\n计算机的组成结构\n\n\n\n3.2 运算器\n算术运算和逻辑运算\n\n在计算机中参与运算的数是二进制的\n\n运算器的长度一般是8、16、32或64位\n\n\n\n3.3 存储器\n存储数据和程序（指令）\n\n容量（存储单元、存储单元地址、容量地址）\n\n分类内存（ROM、RAM）、外存\n\n存储器单位\n\n\n\n3.4 控制器\n指令和程序：指令的形式（操作和地址码、存储程序的概念、指令中程序和数据的存放、指令系统）\n\n指令和数据存储\n\n控制器的基本任务：按照一定的顺序一条接着一条取指令、指令译码、执行指令。取指周期和执行周期\n\n控制器完全可以区分开哪些是指令字，哪些是数据字。一般来讲，取指周期中从内存读出的信息流是指令流，它流向控制器；而在执行器周期中从内存读出的信息流是数据流，它由内存流向运算器。\n\n\n\n3.5 适配器与I/O设备\n输入设备：把人们所熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式\n输出设备：把计算机处理的结果变换为人或其他机器设备所能接收和识别的信息形式\n适配器：它使得被连接的外围设备通过系统总线与主机进行联系，以便使主机和外围设备并行协调地工作\n总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路\n\n​        总之，现代电子计算机是由运算器、存储器、控制器、适配器、总线和输入/输出设备组成的。这也是人们常说的计算机硬件。\n4 计算机的软件4.1 软件的组成与分类​        计算机软件相对计算机硬件来说是看不见，是计算机系统中不可少的无形部件。主要有两大类：\n\n系统软件：用来简化程序设计，简化使用方法，提高计算机的使用效率，发挥和扩大计算机的功能及用途。它包括以下四类：\n\n各种服务性程序，如诊断程序、排错程序、练习程序等\n语言程序，如汇编程序、编译程序、解释程序等\n操作系统\n数据库管理系统\n\n\n应用软件\n用户利用计算机来解决某些问题而编制的程序，如工程设计程序、数据处理程序、自动控制程序、企业管理程序、情报检索程序、科学计算程序等\n\n\n4.2 软件的发展演变\n编程语言的发展\n\n手编程序：机器语言程序，手工编译二进制码\n汇编程序：符号语言程序，汇编程序汇编\n高级程序：算法语言／高级语言，机器编译程序／解释程序\n\n\n系统软件的发展\n\n操作系统\n分布式系统软件\n\n\n\n5 计算机系统的层次结构5.1 多级计算机系统​        五级计算机层次系统\n\n第一级是微程序设计级。这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。\n第二级是一般机器级，也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。\n第三级是操作系统级，它由操作系统程序实现。这些操作系统由机器指令和广义指令组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。\n第四级是汇编语言级，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。\n第五级是高级语言级，它是面向用户的，为方使用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行。\n\n5.2 软件与硬件逻辑等价性\n随着大规模集成电路技术的发展和软件硬化的超势，计算机系统的软、硬件界限已经变得模糊了。因为任何操作可以由软件来实现，也可以由硬件来实现；任何指令的执行可以由硬件完成，也可以由软件来完成。\n任何操作可以由软件来实现也可以由硬件来实现（设计计算机系统时，应考虑各个方面的因素：价格、速度可靠性、存储容量、变更周期）\n实体硬件机功能的扩大\n固件的概念（功能上是软件，形态上是硬件）\n\n","slug":"1 计算机系统概论","date":"2022-10-02T10:37:36.000Z","categories_index":"Computer Organization","tags_index":"Computer Organization","author_index":"Brandon"},{"id":"1c444fa0484aa2cb0030ecd852dcfc6a","title":"User Center","content":"用户中心笔记目标：完整了解做项目的思路，接触一些企业级的开发技术，轻松做出管理系统。\n企业做项目流程需求分析 =&gt; 设计（概要设计、详细设计）=&gt; 技术选型 =&gt; 初始化 / 引入需要的技术 =&gt; 写 Demo =&gt; 写代码（实现业务逻辑） =&gt; 测试（单元测试、系统测试）=&gt; 代码提交 / 代码评审 =&gt; 部署 =&gt; 发布上线\n需求分析\n登录 / 注册\n用户管理（仅管理员可见）对用户的查询或者修改\n用户校验（仅星球用户可见）\n\n技术选型前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）\n后端：\n\njava\nspring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）\nspringmvc（web 框架，提供接口访问、restful接口等能力）\nmybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）\nmybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）\nspringboot（快速启动 / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）\njunit 单元测试库\nmysql 数据库\n\n部署：服务器 / 容器（平台）\n3 种初始化 Java 项目的方式\nGitHub 搜现成的代码\nSpringBoot 官方的模板生成器（https://start.spring.io/）\n直接在 IDEA 开发工具中生成  ✔\n\n如果要引入 java 的包，可以去 maven 中心仓库寻找（http://mvnrepository.com/）\n数据库设计什么是数据库？存数据的\n数据库里有什么？数据表（理解为 excel 表格）\njava 操作数据库？程序代替人工\n什么是设计数据库表？有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？\n举例：性别是否需要加索引？\n用户表设计\n\n\n\n字段\n名称\n类型\n\n\n\n\nid\n主键\nbigint\n\n\nusername\n昵称\nvarchar\n\n\nuserAccount\n登录账号\nvarchar\n\n\navatarUrl\n头像\nvarchar\n\n\ngender\n性别\ntinyint\n\n\nuserPassword\n密码\nvarchar\n\n\nphone\n电话\nvarchar\n\n\nemail\n邮箱\nvarchar\n\n\nuserStatus\n用户状态\nint  0 - 正常\n\n\ncreateTime\n创建时间（数据插入时间）\ndatetime\n\n\nupdateTime\n更新时间（数据更新时间）\ndatetime\n\n\nisDelete\n是否删除 0 1（逻辑删除）\ntinyint\n\n\nuserRole\n用户角色\n0 - 普通用户 1 - 管理员\n\n\n\n\n自动生成器的使用MyBatisX 插件，自动根据数据库生成：\n\ndomain：实体对象\nmapper：操作数据库的对象\nmapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL\nservice：包含常用的增删改查\nserviceImpl：具体实现 service\n\n从而提高开发效率！\n注册逻辑设计\n用户在前端输入账户和密码、以及校验码（todo）\n校验用户的账户、密码、校验密码，是否符合要求\n非空\n账户长度 不小于 4 位\n密码就 不小于 8 位吧\n账户不能重复\n账户不包含特殊字符\n密码和校验密码相同\n\n\n对密码进行加密（密码千万不要直接以明文存储到数据库中）\n向数据库插入用户数据\n\n登录功能接口设计接受参数：用户账户、密码\n请求类型：POST \n请求体：JSON 格式的数据\n\n\n\n\n\n\n\n\n\n请求参数很长时不建议用 get\n返回值：用户信息（ 脱敏 ）\n登录逻辑\n校验用户账户和密码是否合法\n\n非空\n账户长度不小于 4 位\n密码就不小于 8 位\n账户不包含特殊字符\n\n\n校验密码是否输入正确，要和数据库中的密文密码去对比\n\n用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露\n\n我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）\ncookie\n\n返回脱敏后的用户信息\n\n\n实现控制层 Controller 封装请求\napplication.yml 指定接口全局路径前缀：\nservlet:\n  context-path: &#x2F;api\n控制器注解：\n@RestController 适用于编写 restful 风格的 api，返回值默认为 json 类型\n校验写在哪里？\n\ncontroller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）\nservice 层是对业务逻辑的校验（有可能被 controller 之外的类调用）\n\n如何知道是哪个用户登录了？\n\n\n\n\n\n\n\n\njavaweb 这一块的知识\n\n连接服务器端后，得到一个 session 状态（匿名会话），返回给前端\n\n登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ \nsession =&gt; cookie \n\n前端接收到后端的命令后，设置 cookie，保存到浏览器内\n\n前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求\n\n后端拿到前端传来的 cookie，找到对应的 session\n\n后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）\n\n\n用户管理接口设计关键：必须鉴权！！！\n\n查询用户（允许根据用户名查询）\n删除用户\n\n写代码流程\n先做设计\n代码实现\n持续优化！！！（复用代码、提取公共逻辑 / 常量）\n\n前后端交互前端需要向后端发送请求才能获取数据 / 执行操作。\n怎么发请求：前端使用 ajax 来请求后端\n前端请求库及封装关系\naxios 封装了 ajax\n\nrequest 是 ant design 项目又封装了一次\n\n\n追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件\n代理正向代理：替客户端向服务器发送请求，可以解决跨域问题\n反向代理：替服务器统一接收请求。\n怎么实现代理？\n\nNginx 服务器\nNode.js 服务器\n\n举例原本请求：http://localhost:8000/api/user/login\n代理到请求：http://localhost:8080/api/user/login\n\n前端框架介绍Ant Design Pro（Umi 框架）权限管理\napp.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）\naccess.ts 控制用户的访问权限\n\n获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。\nProComponents 高级表单\n通过 columns 定义表格有哪些列\ncolumns 属性\ndataIndex 对应返回数据对象的属性\ntitle 表格列名\ncopyable 是否允许复制\nellipsis 是否允许缩略\nvalueType：用于声明这一列的类型（dateTime、select）\n\n\n\n框架关系Ant Design 组件库 =&gt; 基于 React 实现\nAnt Design Procomponents =&gt; 基于 Ant Design 实现\nAnt Design Pro 后台管理系统 =&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现\n其他知识MFSU：前端编译优化\n后端优化通用返回对象目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败\n200、404、500、502、503\n&#123;\n    &quot;name&quot;: &quot;Brandon&quot;\n&#125;\n\n↓\n\n&#x2F;&#x2F; 成功\n&#123;\n    &quot;code&quot;: 0 &#x2F;&#x2F; 业务状态码\n    &quot;data&quot;: &#123;\n        &quot;name&quot;: &quot;Brandon&quot;\n    &#125;,\n\t&quot;message&quot;: &quot;ok&quot;\n&#125;\n\n\n&#x2F;&#x2F; 错误\n&#123;\n    &quot;code&quot;: 50001 &#x2F;&#x2F; 业务状态码\n    &quot;data&quot;: null\n\t&quot;message&quot;: &quot;用户操作异常、xxx&quot;\n&#125;\n自定义错误码，返回类支持返回正常和错误\n封装全局异常处理器实现\n定义业务异常类\n\n相对于 java 的异常类，支持更多字段\n自定义构造函数，更灵活 / 快捷的设置字段\n\n\n编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）\n\n作用\n捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 / 信息\n同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）\n集中处理，比如记录日志\n\n前端优化\n\n\n\n\n\n\n\n\n直播的 0：00 - 0：35 为踩坑过程，可跳过\n全局响应处理应用场景：我们需要对接口的 通用响应 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。\n优势：不用在每个接口请求中都去写相同的逻辑\n实现：参考你用的请求封装工具的官方文档，比如 umi-request（https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用 axios，参考 axios 的文档。\n创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。\n用户校验\n\n\n\n\n\n\n\n\n仅适用于用户可信的情况\n先让用户自己填：2 - 5 位编号，全凭自觉。\n后台补充对编号的校验：长度校验、唯一性校验\n前端补充输入框，适配后端。\n\n\n\n\n\n\n\n\n\n后期拉取星球数据，定期清理违规用户\n多环境参考文章：https://blog.csdn.net/weixin_41701290/article/details/120173283\n本地开发：localhost（127.0.0.1）\n多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。\n为什么需要？\n\n每个环境互不影响\n区分不同的阶段：开发 / 测试 / 生产\n对项目进行优化：\n本地日志级别\n精简依赖，节省项目体积\n项目的环境 / 参数可以调整，比如 JVM 参数\n\n\n\n针对不同环境做不同的事情。\n多环境分类：\n\n本地环境（自己的电脑）localhost\n开发环境（远程开发）大家连同一台机器，为了大家开发方便\n测试环境（测试）开发 / 测试 / 产品，单元测试 / 性能测试 / 功能测试 / 系统集成测试，独立的数据库、独立的服务器\n预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题\n正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行\n沙箱环境（实验环境）：为了做实验\n\n前端多环境实战\n请求地址\n\n开发环境：localhost:8000\n\n线上环境：user-backend.code-nav.cn\n\n\nstartFront(env) &#123;\n    if(env &#x3D;&#x3D;&#x3D; &#39;prod&#39;) &#123;\n        &#x2F;&#x2F; 不输出注释 \n        &#x2F;&#x2F; 项目优化\n        &#x2F;&#x2F; 修改请求地址\n    &#125; else &#123;\n        &#x2F;&#x2F; 保持本地开发逻辑\n    &#125;\n&#125;\n用了 umi 框架，build 时会自动传入 NODE_ENV == production 参数，start NODE_ENV 参数为 development\n\n启动方式\n\n开发环境：npm run start（本地启动，监听端口、自动更新）\n线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）\n\n\n项目的配置\n不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：https://umijs.org/zh-CN/docs/deployment\n\n开发环境：config.dev.ts\n生产环境：config.prod.ts\n公共配置：config.ts 不带后缀\n\n\n\n后端多环境实战SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件\n可以在启动项目时传入环境变量：\njava -jar .\\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;prod\n主要是改：\n\n依赖的环境地址\n\n数据库地址\n\n缓存地址\n\n消息队列地址\n\n项目端口号\n\n\n\n服务器配置\n\n\n项目部署参考文章：https://www.bilibili.com/read/cv16179200\n需要 Linux 服务器（建议大家用 CentOS 8+ / 7.6 以上）\n原始部署什么都自己装\n前端需要 web 服务器：nginx 、apache、tomcat\n安装 nginx 服务器：\n\n用系统自带的软件包管理器快速安装，比如 centos 的 yum\n\n自己到官网安装（参考文章）\ncurl -o nginx-1.21.6.tar.gz http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.21.6.tar.gz\n\ntar -zxvf nginx-1.21.6.tar.gz\n\ncd nginx-1.21.6\n\n   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y\n   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y\n   41  2022-04-17 23:31:57 .&#x2F;configure --with-http_ssl_module --with-http_v2_module --with-stream\n   42  2022-04-17 23:32:13 make\n   43  2022-04-17 23:32:54 make install\n   48  2022-04-17 23:33:40 ls &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx\n   vim &#x2F;etc&#x2F;profile\n  在最后一行添加：export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin\t\n  \n  nginx\n  \n  netstat -ntlp 查看启动情况\n注意 nginx 权限\n\n\n后端java、maven\n安装：\nyum install -y java-1.8.0-openjdk*\n\ncurl -o apache-maven-3.8.5-bin.tar.gz https:&#x2F;&#x2F;dlcdn.apache.org&#x2F;maven&#x2F;maven-3&#x2F;3.8.5&#x2F;binaries&#x2F;apache-maven-3.8.5-bin.tar.gz\n\ngit clone xxx 下载代码\n\n打包构建，跳过测试\nmvn package -DskipTests\n\njava -jar .&#x2F;user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;prod\n宝塔 Linux 部署Linux 运维面板\n官方安装教程：https://www.bt.cn/new/download.html\n方便管理服务器、方便安装软件\n前端托管前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）\n\n\n\n\n\n\n\n\n\nhttps://console.cloud.tencent.com/webify/new\n\n小缺点：需要将代码放到代码托管平台上\n优势：不用写命令、代码更新时自动构建\n\nDocker 部署docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。\n再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。\ndocker 可以理解为软件安装包。\nDocker 安装：https://www.docker.com/get-started/ 或者宝塔安装\nDockerfile 用于指定构建 Docker 镜像的方法\nDockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）\nDockerfile 编写：\n\nFROM 依赖的基础镜像\nWORKDIR 工作目录\nCOPY 从本机复制文件\nRUN 执行命令\nCMD / ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令\n\n根据 Dockerfile 构建镜像：\n# 后端\ndocker build -t user-center-backend:v0.0.1 .\n\n# 前端\ndocker build -t user-center-frontend:v0.0.1 .\nDocker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）\ndocker run 启动：\n# 前端\ndocker run -p 80:80 -d user-center-frontend:v0.0.1\n\n# 后端\ndocker run -p 8080:8080 user-center-backend:v0.0.1\n虚拟化\n\n端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联\n目录映射：把本机的端口和容器应用的端口进行关联\n\n进入容器：\ndocker exec -i -t  fee2bbb7c9ee &#x2F;bin&#x2F;bash\n查看进程：\ndocker ps \n查看日志：\ndocker logs -f [container-id]\n杀死容器：\ndocker kill\n强制删除镜像：\ndocker rmi -f\nDocker 平台部署\n云服务商的容器平台（腾讯云、阿里云）\n面向某个领域的容器平台（前端 / 后端微信云托管）要花钱！\n\n容器平台的好处：\n\n不用输命令来操作，更方便省事\n不用在控制台操作，更傻瓜式、更简单\n大厂运维，比自己运维更省心\n额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）\n\n绑定域名前端项目访问流程：用户输入网址 =&gt; 域名解析服务器（把网址解析为 ip 地址 / 交给其他的域名解析服务） =&gt; 服务器 =&gt;（防火墙）=&gt; nginx 接收请求，找到对应的文件，返回文件给前端 =&gt; 前端加载文件到浏览器中（js、css） =&gt; 渲染页面\n后端项目访问流程：用户输入网址 =&gt; 域名解析服务器 =&gt; 服务器 =&gt; nginx 接收请求 =&gt; 后端项目（比如 8080端口）\nnginx 反向代理的作用：替服务器接收请求，转发请求\n跨域问题解决浏览器为了用户的安全，仅允许向 同域名、同端口 的服务器发送请求。\n如何解决跨域？\n最直接的方式：把域名、端口改成相同的\n添加跨域头让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）\n1. 网关支持（Nginx）# 跨域配置\nlocation ^~ &#x2F;api&#x2F; &#123;\n    proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;;\n    add_header &#39;Access-Control-Allow-Origin&#39; $http_origin;\n    add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n    add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;\n    add_header Access-Control-Allow-Headers &#39;*&#39;;\n    if ($request_method &#x3D; &#39;OPTIONS&#39;) &#123;\n        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n        add_header &#39;Access-Control-Allow-Origin&#39; $http_origin;\n        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#39;;\n        add_header &#39;Access-Control-Max-Age&#39; 1728000;\n        add_header &#39;Content-Type&#39; &#39;text&#x2F;plain; charset&#x3D;utf-8&#39;;\n        add_header &#39;Content-Length&#39; 0;\n        return 204;\n    &#125;\n&#125;\n2. 修改后端服务\n配置 @CrossOrigin 注解\n\n添加 web 全局请求拦截器\n@Configuration\npublic class WebMvcConfg implements WebMvcConfigurer &#123;\n \n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n        &#x2F;&#x2F;设置允许跨域的路径\n        registry.addMapping(&quot;&#x2F;**&quot;)\n                &#x2F;&#x2F;设置允许跨域请求的域名\n                &#x2F;&#x2F;当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】\n                .allowedOrigins(&quot;http:&#x2F;&#x2F;localhost:9527&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:9527&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8082&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8083&quot;)\n                &#x2F;&#x2F;是否允许证书 不再默认开启\n                .allowCredentials(true)\n                &#x2F;&#x2F;设置允许的方法\n                .allowedMethods(&quot;*&quot;)\n                &#x2F;&#x2F;跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n\n定义新的 corsFilter Bean，参考：https://www.jianshu.com/p/b02099a435bd\n\n\n项目优化点\n功能扩充\n管理员创建用户、修改用户信息、删除用户\n上传头像\n按照更多的条件去查询用户\n更改权限\n\n\n修改 Bug\n项目登录改为分布式 session（单点登录 - redis）\n通用性\nset-cookie domain 域名更通用，比如改为 *.xxx.com\n把用户管理系统 =&gt; 用户中心（之后所有的服务都请求这个后端）\n\n\n后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）\n\n","slug":"User Center","date":"2022-08-05T09:01:36.000Z","categories_index":"Project","tags_index":"Project","author_index":"Brandon"}]
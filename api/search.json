[{"id":"7b17ab8fd94c1b49243bcf846271ed72","title":"Hackenet Walkthrough","content":"Tutorial篇\n嗨，我的名字是bit 當你讀到這條訊息的時候我已經死了…\nStream游戏hacknet，讲的是一个黑客，生命最后的一段故事…\n\n\n\n\n\n\n\n\n\n\n在你连接到任何系统之后，你需要做的第一件事便是扫描它的相关节点。这将会在地图上显示其相关节点，现在扫描这台电脑。\n\n点击扫描网络\n\n\n\n\n\n\n\n\n\n\n是时候连接到一台外部计算机了。注意：试图破坏他人计算机的安全将违反条规。现在开始为自己的行为负责吧。\n\n点击新出现的网络\n\n\n\n\n\n\n\n\n\n\n这个虚拟机的终端模块已经被激活，这将是你用于导航的主菜单。可以输入一个命令，然后按回车键来运行。查看计算机的安全系统和活动端口可以使用probe命令，来分析当前连接的计算机。\n\n输入 probe\n\n\n\n\n\n\n\n\n\n\n在这里你可以看到活动端口，已经激活的安全系统和需要破解的端口数，你需要破解规定数量的端口才能运行 porthack。这台服务器没有已经激活的安全系统，需要破解的端口数量是0，使用 porthack 开始破解吧。\n\n输入 porthack\n\n\n\n\n\n\n\n\n\n\n恭喜！你已经控制来这个外部系统，现在你是该系统的管理员，你可以做任何事，但是你最好先扫描本机的相关节点，使用命令 scan。\n\n输入 scan\n\n\n\n\n\n\n\n\n\n\n没有结果，没有就没有吧。下一步，查看文件系统。\n\n点击查看文件系统\n\n\n\n\n\n\n\n\n\n\n访问 bin 文件夹来搜索有用的可执行文件，使用命令 cd 文件夹名。\n\n输入 cd bin\n\n\n\n\n\n\n\n\n\n\n要查看当前文件夹的内容，使用 ls 命令，这里没有程序，但是你最好查看 config.txt 以防止漏掉有用的信息。\n\n点击 config.txt\n\n\n\n\n\n\n\n\n\n\n然而这里卵都没有！现在你要清理你访问的痕迹，返回上一个目录使用 cd ..\n\n输入 cd ..\n\n\n\n\n\n\n\n\n\n\n进入 log 文件夹\n\n输入 cd log\n\n\n\n\n\n\n\n\n\n\n删除此目录中的所有文件，你可以使用 rm 文件名，也可以使用 rm * 删除全部文件。\n\n输入 rm *\n\n\n\n\n\n\n\n\n\n\n干的很好，与此台计算机断开连接，你可以使用 dc 命令。\n\n输入 dc\n\n\n\n\n\n\n\n\n\n\n恭喜，你已经完成本教程的所有内容。想结束本教学，你需要找到本教学程序的 PID，并结束它。help 命令可以给你列出完整的命令列表。\n\n输入 help\n\nhelp [page number] 显示命令所知定的页面\nscp [filename] [destination] 此远程计算机复制文件[filename]到指定本地文件夹(默认是&#x2F;bin)\nscan 在已连接计算机上扫描节点并加入服务器地图\nrm [filename] 删除文件\nps 列出正在运行的程序以及它们的PIDs\nkill [PID] 结束PID\nls 列出所有文件\ncd [foldername]去指定的目录下\nmv [file] [destination] 移动或重命名文件file到destination\nconnect [ip] 连接到外部计算机\nprobe 扫描已连接计算机的活动端口及保安级别\nexe 列出所有可执行文件在local&#x2F;bin目录／文件夹\ndc 终止连接\ncat [filename] 显示文件内容\nopenCDTray 打开已连接计算机的CD托盘\ncloseCDTray 关闭已连接计算机的CD托盘\nreboot [-i] 重启已连接计算机，使用-i选项直接重启\nreplace [filename] &quot;target&quot; &quot;replacement&quot; 以需要替换的文本替换文件中的目标文本\nanalyze 对目标计算机的防火墙分析\nsolve [firewall solution] 试图解决目标计算机的防火墙以允许UDP流量\nlogin 要求用户名和密码登陆已连接的系统\nupload [local file path] 上传到本地计算机上指定的文件到当前连接的目录\nclear 清楚终端\naddnote [note] 添加笔记\nappend [filename] [data]\nshell 过载\n\n输入 ps\n\nUID ： PID ： NAME\nroot ：238 ： Tutorial\n\n输入 kill 238\n\n游戏引导环节结束。\n\n\n\n\n\n\n\n\n\nhi 我不认识你，而且很遗憾的是我也没有机会再认识你了，但是如果你读到这封邮件，那就意味着你还有机会挽救这一切。我现在深陷危机，留给我的时间已经不多了，有件事我想求你帮我，但是在这之前，还有一件更重要的事情需要你尽快处理，越快越好。现在这个状态的hacknet操作系统并不应该发布出去…你的电脑马上就会有一个追踪软件自动激活，赶快删掉它。连接到你自己的节点，然后找到并删除”securityTracer.exe”当你完成时，回复这个邮件就行，快快快。—bit0\n接到第一条黑客邮件：初次联系\n\n\n\n\n\n\n\n\n目标：删除 securityTracer.exe\n\n进入 /bin 目录，然后 rm * 即可\n进入信箱，点击回复即可\n\n接到第二条黑客邮件：让我们来获取一些工具\n\n\n\n\n\n\n\n\n很好，你现在应该安全了！至少在你的电脑上…在我们开始之前，你需要获取一些工具，只使用 porthack 是无法入侵你将来发现的大部分电脑的…至少你入侵不了那些你感兴趣的东西。你应该从调查我朋友的服务器开始，他自称自己是毒蛇Viper，听起来很可怕是吧？老实说…他干这个水平不咋地，但他总是有一些实用的代码。入侵他的电脑对你来说应该不是问题，问题在于能否找到有用的文件。在大多数情况下，你可以忽略一些关于登陆记录，程序的存储文件，IRC日志等等这种普通文件。像后缀名是 exe 的文件，才是你要寻找的。你可以使用 scp 下载任何文件。祝你好运 ～完成之后我给回信。—bit0\n\n输入 probe 检测系统，发现所需破解的端口数量为0\n输入 porthacck，成功入侵\n点击登陆，进入 /bin 目录下，发现 SSHCrack.exe\n输入 scp SSHcrack.exe，即可成功下载到本地 /bin 目录下\n回复邮件，完成任务\n\n接到第三条黑客邮件：初试牛刀\n\n\n\n\n\n\n\n\n祝贺！说实话…你这样回复我，也不知道你成功了没有，不过既然你正在读这封邮件，意味着牛至少发现了一些东西，我先假定你找到了那程序是有用的，你应该试着入侵我的一个旧的服务器。如果Viper有用于入侵的工具的话，你应该已经获得了所需的工具。记住，运行任何非基础的程序都需要提供端口号。比如：SSHcrack 22只需要找到一个你想破解的端口，然后像上面这样运行即可。对了，提醒你一下，你可以使用 Tab 自动补全命令！祝你好运 ～—bit0\n\n点击 Bitwise 测试PC（84.252.58.158）\n点击检测系统（probe），发现需要破解一个端口\n输入 sshcrack 22，即可破解22端口\n输入 porthack，即可成功入侵\n完成任务，回复邮件\n\n\n\n\n\n\n\n\n\n\nlog：[hack1]我在等老板走[hack1]然后我会在后边与你汇合[hack2]你认为他会有什么好注意吗？[hack1]呵呵，我想不会。[hack1]他根本不知道接下来一坨麻烦事。[hack2]别忘记清楚浏览器历史记录，我可不希望他通过这些记录找到我们[hack1]好好好，我已经把它覆盖掉了。[hack1]他刚刚拿起他的大衣，现在正走向门口…[hack2]OK，给我一些时间调整摄像头的供电系统…[hack2]搞定！在干扰图像消失之前你有3分钟时间。[hack1]我会拿到那份名单的，然后我们可以喝点啤酒庆祝一下。\n\n[hack1]你一定不会相信我要说的事情。[hack2]什么？[hack2]那东西起作用了吗？[hack1]有佣兵为了源，闯入了我的房间。[hack2]我靠，好像你惹到了大的利益集团了。[hack2]报酬应该很好把？[hack1]一万二美刀，对两个月工作来说算不错的报酬。[hack1]我真想知道它们会把它用来干嘛。[hack2]他们可能用来掏空你的银行账户。[hack1]哈哈，账户里面压根没有钱，让他们偷去吧。\n\n[hack1]结局是好的，那个白痴比尔被解雇了，而我安全了。[hack2]很好。[hack1]我一直讨厌比尔，你帮了我一个忙。[hack2]更不用说那一万美刀的回扣，对吧？[hack1]当然，那也对我帮助很大。[hack1]所以我们现在都搞定了？[hack2]都搞定了，我会花上几个月专门待在哪里。[hack1]日后再会，老板。\n接到第四条黑客邮件：善始善终\n\n\n\n\n\n\n\n\n好样的，从现在开始事情变得越来越复杂了，我需要你帮我一个忙。最近我因一点点小马虎给自己惹了不少麻烦，这就是为什么我给你写这封邮件。总而言之，我的意思是，有几台电脑上有一些我不想存放在那里的操作日志。你一定要记住这点，不要忘记删掉你的操作日志。如果你之前从没删过，那从现在开始。你在任何现代的操作系统上所做的一切都会被跟踪记载在日志文件夹下。只要进入这个目录，然后 rm *，即可删除所有信息。永远不要忘记这点。—bit0任务细节：删除目标计算机上日志文件夹里的所有文件。目标服务器：P.Anderson的卧室电脑#12.27.26.43\n\n点击P.Anderson的卧室电脑（12.27.26.43）\n点击检测系统（probe），发现需要破解一个端口\n输入 sshcrack 22，即可破解22端口\n输入 porthack，即可成功入侵\n进入 /log 目录，rm *\n完成任务，回复邮件\n\n\n\n\n\n\n\n\n\n\nlog：[hack1]准备好出去浪了吗？[hack2]那取决于…[hack2]你准备好去死了吗？[hack3]哈哈哈[hack1]闭嘴[hack1]忘记你上次打翻花生酱的事情了？[hack3]别提那次的时期了[hack1]就那一次就够你受的了[hack1]有谁知道hack4在哪吗？[hack2]没人知道他去哪了[hack2]可能是有个魔法怪物把他抓走了吧[hack1]严肃点，我们的计划被打乱了[hack1]为什么每次我担心的事情总会发生？\n接到第五条黑客邮件：生涯起点\n\n\n\n\n\n\n\n\n好样的！如果你收到这封邮件，说明你做的很好…嗯，也许这一切真是值得的。我对你抱有的期望是不是太大了？也许吧。我知道我没有充裕的时间来一点点教你，你要学习的东西太多来。所有，我的决定如下：有一个叫Entropy的黑客组织目前正在招收新成员，他们会教你更多的黑客知识。当你的黑客技术足以帮我完成夙愿时，我会再联系你。为了进入Entropy，你需要绕过一个代理服务器。在你已经取得管理员权限计算机上运行几个 shell，它可以用来过载服务器。祝你好运…还有，谢谢你。—bit0差点忘记了，如果你遇到麻烦，我有网络教育档案服务器的链接，这个服务器上面有很多有用的信息。网络教育档案管(228.70.237.9)\n\n点击Entropy测试服务器（199.59.149.230）\n点击 检测系统，检测到代理，并且需要破解一个端口\n点击自己的服务器，输入 shell\n点击Entropy测试服务器，发现代理已经失效\n输入 sshcrack 22，破解成功\n输入 porthack，入侵成功\n关闭 shell\n进入 /home 目录下\n输入 scp Entropy_Induction_Test 下载文件，即可完成任务\n进入 /log，删除日志\n\n\n\n\n\n\n\n\n\n\n代理服务器：代理服务器的作用相当于在目标计算机和对应连接设备之间形成一个缓冲层，能够监控并过滤传入的流量，起到缓冲作用。它可以通过优化重复访问来提高网络性能，并能够阻止某些类型的攻击。代理服务器最广为人知的缺点就是它的存储上限，一旦代理服务器的存储空间占满，它就无法再阻止数据流的通过。为了利用这个缺陷，黑客往往在其他计算机上运行shell，当你在足够多的肉鸡上运行了shell后，就可以连接到目标计算机并使用shell的overload功能来发动泛洪攻击，用大量垃圾数据填满目标的代理服务器，这样就可以让有害的数据流通过。\nexe文件和远程执行：在现代终端中，exe命令会在本地计算机调用相应的程序去执行目标文件。实际上，这个命令被叫做某种快捷方式。原本在远程执行任何命令时，都必须附加上链接的计算的IP地址作为参数，但使用exe命令可以避免这样的繁琐操作，这也允许来多个程序在一个套接字上发送数据流量，这也在操作系统级别上提高来网络效率。当然，需要exe文件本身没有网络功能，在这种情况下，该程序会会忽略跨网络套接字并在本地执行该exe文件。\nshells：shell是运行在单一主机上的低内存占用的小型进程，可以用任何连接方式在本地对它进行操控，这个及其方便的程序在许多任务中都是及其有用的，当然他们能干什么取决于运行的shell的种类。常规跨网络的功能有：\noverload（过载）：过载用于测试网络和代理服务器，这个功能可以使得运行shell的节点向目标机器发起泛洪攻击。用大量垃圾网络流量占满代理服务器的内存，并消耗其CPU时间。\ntrap（陷阱）：该模式会提醒用户是否有外来用户在本机器上运行shell，并允许对所有远程连接到本计算机的用户执行forkbomb攻击。该模式在远程维护计算机安全又同时进行其他工作的时候非常有用。\n防火墙的分析和破解：使用防火墙来维护计算机安全的手段已经历史悠久了，曾经它不是专门针对黑客的攻击，而是用来防止自动的外部网络访问的。然而，现代防火墙可以阻断所有触发安全报警的流量，除非附加了防火墙破解指令。在这种情况下，需要提高防火墙的破解指令才能破解防火墙，否则，在防火墙已经激活的状态下，一个未经允许的用户使用任何已知的密码破解工具来尝试登陆都是无效的。使用命令analyze可以分析防火墙的复杂度。多次使用分析命令可以自动检测相应数据头中的信息，并将非防火墙破解指令信息排除，一旦发现潜在的破解指令，就可以使用命令solve来尝试破解。\n代理服务器高级：代理服务器基本上可以说是同目标设备连接之间的第二台设备，它能够缓存并过滤网络数据流，保障网络安全，提升网络性能。代理服务器默认设置为阻挡那些可能被认为是网络威胁的数据流，同时将那些可取的数据流加入白名单。这就意味着，如果设置不当的话，代理服务器会给使用者带来不便，但是如果设置合理，它就能够阻止那些损害端口安全的程序的运行。代理服务器最广为认知的缺点就是它的存储上限，一旦代理服务器的存储空间占满，要么将整个服务器网络全部关闭，要么就允许未检查的数据流通过。因此，可以通过增加预算来升级代理服务器的内存，让过载过程变得冗长而缓慢，这样以来几乎能够无视单一机器发动的泛洪攻击。\n追踪-被动模式：为了应对日益恶劣的计算机安全世界和黑客世界，新的数字安全套件包含了追踪敌对服务器位置的方法。由于科学的天然不完美性，追踪的方法分为2种形式：主动模式和被动模式。被动模式追踪是在一个计算机上运行的程序，它会检测所有试图攻击的行动，并对攻击者进行追踪，这是一种程序到程序的方法。被动模式可以在理论上阻止攻击的完成，使得敌对服务器在特定时间段不能返回报文，产生数据包没有送达的假象。该操作需要系统层次的结合，并且不是我们已知的任何操作系统的特征，因此，这是一个有效的追踪方法。\n追踪-主动模式：主动模式追踪是一种由技术人员手动操作的追踪，比如追查到当前已经激活的链接，或者用粗心的黑客留在服务器上的log来追踪反查。主动模式追踪是无法被反追踪的，通常用于破坏路由路径节点的安全系统并查看连接日志。可以通过破坏链接接的方式来阻挡主动模式追踪，这样一来追踪者就没有可前进的路线了，同样的，如果使用主动模式追踪进攻的话，强烈建议速战速决。\n接到第六条黑客邮件：任务完成\n\n\n\n\n\n\n\n\n你好，ailx11，首先祝贺你通过了Entropy黑客组织的考试！当然了，这种程度的考试对于一个经验丰富的黑客来说是小事一桩，然而令人经验的是，能通过这场考试的人并不多。在你正式加入我们组织之前，我们必须对你的能力进行进一步的考验。最近，有一家新闻网站摆明了同我们的对立立场。我们希望你能够临时瘫痪他们的服务器。作为测试你的能力的第二项任何，我们要求你搞垮他们的新闻板块。如果可以的话，不要破坏无关的服务器和那些与Entropy无关的文章。我们没必要做的那么绝。这项任务可不是仅仅让你删除文章那么简单，我们要搞垮他们的程序。—Tex目标：Slash-Bot新闻网（18.213.180.106）\n\n点击Slash-Bot新闻网，可以看到一些新闻，点击 退出\n点击 检测系统，检测到代理，并需要破解一个端口\n点击自己的大本营，输入 shell，点击过载\n点击Slash-Bot新闻网\n输入 sshcrack 22\n输入 porthack，入侵成功，关闭 过载\n点击 登录，点击 查看文件系统\n进入 msgboard 目录，删除 config.sys\n删除日志，回复邮件，完成任务\n\n\n\n\n\n\n\n\n\n\n新闻内容：Entropy黑客组织要转型为骇客？最近报道称，黑客组织Entropy收留了一个臭名昭著的骇客，并且为他提供了工作，我们还不确定这个消息的真实性，如果消息属实，那么Entropy组织在将来一定会面临严峻的法律问题。在我看来，这样的举动会破坏现在良好的网络环境，遏制那些富有创造力的黑客组织的发展，Entropy应当受到严厉的谴责—记者：tom wilkins\nEntropy引起了公众的疑心在当今的网络世界中，黑客组织Entropy因长期提供大量可靠的资源信息而出名，然而，该组织最近采购了一些可疑信息之后，就关闭了他们的公共信息终端，这样的行为引起了同行们的疑心。虽然这个组织长时间以来因信息开源而在公众间享有良好的名誉，但如果该组织做出不正当行为的话，相关人士就必须采取措施了。我们将跟踪报道事态的发展。—记者：tom wilkins\n接到第七条黑客邮件：欢迎\n\n\n\n\n\n\n\n\n欢迎你，ailx11，恭喜，你出色及时的完成了你的第一项任务，让我们见识到你的能力，现在，我诚挚的欢迎你来到Entropy黑客组织，在我们的资源服务器里，你可以找到管理员账户的详细资料，作为组织送你的见面礼，你可以去资源服务器里随意下载你需要的程序，同时记着我们组织的宗旨，一旦你准备好，请回复这封邮件，我会给你安排一些真正有挑战的任务，再次恭喜你通过测试.—texEntropy资源服务器（85.132.50.122）Entropy资源服务器（user=admin pass=rosebud）\n\n登陆Entropy资源服务器，进入 bin 目录\nscp ftpbounce.exe，获取黑客工具\n回复邮件，完成任务\n\n\n\n\n\n\n\n\n\n\nlog：Entropy宗旨我们的组织建立在三个准则之上，我们力求做到这三点：1）在任何事情上努力追求正义和公正2）我们追求创造和分享，而不是毁灭3）永远不要为停滞不前而寻找理由我们组织不会接受，也不允许违背这三条准则的成员，违反这三条准则的成员将会被直接开除。\n接到第八条黑客邮件：re：欢迎\n\n\n\n\n\n\n\n\nailx11，很好，看来你拿到了你所需要的东西，那么，你可以正式开始接受Entropy黑客组织的各项任务了，附件里我给出了我们组织的任务资源数据库的ip地址，还一并给出了你的用户名和密码以及用户获取登陆权限，当你有空的时候，就去接受并完成你的第一项任务吧。届时我们将会再次评估你的任务进度。—texEntropy任务数据库（234.232.6.213）Entropy任务数据库（user=ailx11 pass=rosebud）\n\n登陆Entropy任务数据库，输入用户名和密码\n\n\n\n\n\n\n\n\n\n\n可承接的合同：\n\nPoint clicker\n一个热心的客户希望我们删除他在游戏服务器上的存档，\n以此来延续他对游戏的兴趣。\n\n\n经典的反黑客攻击\n最近我们得到消息，某家公司招聘到的员工越来越少…根据猜测，应该是他的竞争对手公司出于不良目的，雇佣了黑客来窃取公司的敏感信息，为了避免以后的公司都雇佣黑客来干坏事，我们决定阻止他们的交易。\n\n\n重回学校\n一位高中的负责人在不久前联系我们，他想查明学校的IT部门是否在位授权的情况下查看了学生的私人数据，他不想破坏任何数据，只是想偷偷的搞到其中一个员工的登陆密码，这样他就可以自己调查这件事了。\n\n\nx-c项目\n这次任务有点奇怪，一个富商向我们寻求帮助，他需要我们调查他的同事是否在工作时用笔记本电脑处理私事，我们事先粗略的调查了一下他们的系统，看起来他们好像痴迷于外星人，他们是角色扮演戏团，还是外星人阴谋论者？\n\n\nbanished stallion solutions 疏漏的数据\n一个黑客组织偷走了某公司的珍贵数据，目前这些黑客已被绳之以法，不过他们必须将偷走的东西归还原主。\n\n\nbeagle solutions 恐吓手段\n我们的一位重要客户的同事最近有点过于嚣张，去给他们提个醒。摧毁他们最近创建的服务器备份。\n\n\n\n\n选择第一份合同：Point clicker\n\n接到第九条黑客邮件：Point clicker\n\n\n\n\n\n\n\n\n你好，我现在有点郁闷，但更倒霉的事，没有一个同事能帮我，虽然我很反感向外界寻求帮助，但是我只能这么做了，把你们组织介绍给我的的那个人，向我保证你们会保密，所以我就简要说明一下：我在pointclick里已经刷到无敌了，我希望我能再刷一遍来证明我的王者低位，然而这个游戏没有重制按钮，我希望你们能黑进游戏服务器删除我的存档，这样我就能再爽一次了，我的用户名是mengskPointclicker（172.95.135.71）\n\n点击Pointclicker，点击检测系统，需要破解2个端口\nsshcrack 22\nftpbounce 21\nporthack，入侵成功\n点击 登录，点击 文件系统，进入 pointclicker 目录\n进入 saves 目录，\nrm Mengsk.pcsav，删除存档文件\n回复邮件，完成任务\n\n接到第十条黑客邮件：合同完成\n\n\n\n\n\n\n\n\n恭喜，你接受的任务已经完成，客户对你的工作非常满意，你现在可以去数据库里随意接受其他任务了，你现在在100个人里排名第80谢谢\n\n登陆Entropy任务数据库，输入用户名和密码（user=ailx11 pass=rosebud）\n接受重回学校的任务\n\n接到第十一条黑客邮件：重回学校\n\n\n\n\n\n\n\n\n各位黑客，魔法高中的管理层联系到我们，希望我们能悄悄的搞到他们IT部门员工的管理员密码，以此就IT部门保存了学生的什么数据来展开一项调查，当你入侵时务必使一切数据都保留原样，任何的篡改将会影响到管理人员的判断，而你需要做的，就是黑进去，找到密码，然后清除你的操作日志，把密码回复给我，至于如何把密码交给学校的管理层就不需要你操心了。祝你好运。魔法高中IT办公室（46.120.228.83）\n\n点击魔法高中IT办公室，点击 检测系统\n检测到代理，并需要破解1个端口\n进入自己大本营，输入 shell\n进入魔法高中IT办公室，点击 过载\n代理失效后，输入 ssh 22，\n输入 porthack，入侵成功，关闭过载\n点击 登录，进入 文件系统\n进入 pw_memo.log 文件，找到密码 ******* ，7个 *\n删除日志\n回复邮件，输入 *******，完成任务。\n\n\n\n\n\n\n\n\n\n\n[老运维]我一直在想咱们学校的网络安全系统[新鸟]是么[老运维]我局的这些升级神马都是劳民伤财[老运维]你试试这个[老运维]最简单的办法[老运维]我们只需要把IT的密码设置成这个[老运维]*[新鸟]什么鬼[老运维]就是这个啊！[老运维]就是7个*啊[老运维]这就是密码，只有星号[老运维]谁会想到这个是密码？肯定没有人能猜到！[老运维]就算有人黑到了密码，那看起来也像是被加密的密码[新鸟]什么鬼，这简直牢不可破啊！\n关于网络、代理服务器瘫痪的通知虽然我们的一部分员工不知道代理服务器瘫痪是什么意思，但是很明显我们的一部分学生知道那意味着什么。在通知发出的那个晚上，很明显发现了网络连接依然可用，但是防火墙并没有工作。在接下来的20分钟里有22T的爱情动作片被下载到了学校的服务器和各个房间的店内。很明显我们想通过加强安全手段避免这件事情再一次发生，也许，不通知学生这种事情会好很多。非常感谢！—校长办公室\n学生搜索Top10历史记录1 谷歌2 双峰3 胸4 性5 侧乳6 爱情动作片7 能怎么阻止防火墙8 能绕过防火墙的网站9 南北战争的油画10 GTA侠盗猎车手\n接到第十二条黑客邮件：RE：重回学校\n\n\n\n\n\n\n\n\n你确定？*我不知道想出这种密码的人是天才还是白痴，还是说两者都是？妈的，我是说，当初我也找到了这个密码，而且我的验证脚本显示这个密码是正确的，然而我还在继续独自破解那些星号！这就他妈的尴尬了…这你叫我怎么去跟学校的头头们解释？不论怎么说…问题解决了，你做的不错。—管理员\n接到第十三条黑客邮件：合同完成\n\n\n\n\n\n\n\n\n恭喜，你接受的任务已经完成，客户对你很满意。你现在可以去数据库里随意接受其他任务了，你现在在100个人中的排名是第60名，谢谢。\n\n登陆Entropy任务数据库，输入用户名和密码（user=ailx11 pass=rosebud）\n接受任务，经典的反黑客工具\n\n接到第十四条黑客邮件：经典的反黑客攻击\n\n\n\n\n\n\n\n\n你好黑客，PP市场最近雇佣了一名自由黑客，他入侵了竞争对手公司的服务器窃取了一些敏感信息，我们猜测应该是邮件形式的简历列表，他把这些简历从对手公司的服务器里删掉，并将简历转交给了雇主公司的招聘部门，这种商业间谍行为很明显是在给黑客的声誉抹黑，虽然我们对他们公司的竞争不感兴趣，但是PP市场公司雇佣黑客的消息已经走遍整个网络，所以我们要确保PP市场这次吃不了兜着走，我们不知道那些文件的确切名字，所以你找的时候要费点心思，记住，你要找到并删除的是一份被偷走的邮件列表，它们可能被加密或归档，注意，PP公司可能对此有所防范，他们应该会采取相应的安全措施—Entropy管理员PP市场公司（242.60.58.190）\n\n点击PP市场公司，点击 检测系统\n检测到代理，并需要破解2个端口\n进入自己大本营，输入 shell\n进入PP市场，过载\n代理失效后，输入 sshcrack 22，ftpbounce 21\n输入 porthack，入侵成功\n输入 dc，这时候警报解除\n登录 PP市场公司，查看 文件系统\n/home/workspace/secure_maillist.dec\nscp secure_maillist.dec，下载一份到本地\nrm secure_maillist.dec 删除PP市场公司的邮件列表\n回复邮件，完成任务\n\n\n\n\n\n\n\n\n\n\n这就是我们从黑客手中得到的邮件列表，顺便提一下，我们给这家伙付了不少钱，结果这邮件列表还是加密的？那我们为啥要付钱给这个黑客？HR说他会找其他人来尝试破解这个邮件列表，或者只要有人能从中提取出有用的东西都行，根绝黑客的说法，这个文本的大小是正确的，所以只要我们能破解开这个文件，我们就能得到正确的数据，真麻烦。好吧，至少这邮件列表确实在我们手里来，虽然我们打不开\n接到第十五条黑客邮件：合同完成\n\n\n\n\n\n\n\n\n恭喜，你接受的任务已经完成，客户对你的工作很满意。你现在可以去数据库里随意接受其他任务了，你现在在100人中排名第40，谢谢。\n接到第十六条黑客邮件：eOS设备扫描\n\n\n\n\n\n\n\n\n给位黑客你们好，根据任务需要，我们引进了一项新科技，正好你在线，我们希望你能够接受这个任务，帮我们测试一下这个新东西，这项任务需要获取目标手机的操作系统权限，一个eOS设备，我们联系到了这个领域的一位专家，他同意向我们提供相关工具，不过记住，他所提供的工具并没有经过实际测试，—-重要—-我一会儿会把这个工具的相关信息转发给你，你先读完这封邮件，一旦你获取了手机权限，找到该手机持有者的邮箱账号的密码，请把密码回复给我，剩下的交给我来处理祝你好运—Entropy管理员目标：Jason PowerBook Plus（17.146.21.92）\n接到第十七条黑客邮件：Fwd：eOS Stuff\n\n\n\n\n\n\n\n\n嘿 Entropy的伙计们，eOS设备扫描器已经上传到你们的资源服务器（~/bin/eosDeviceScanner.exe）应该能够作为一个标准的目标连接程序来运行，因为该程序需要在系统文件夹里访问大量文件，来得到和目标电脑同步数据的设备的信息，你需要在运行程序之前得到目标机器的管理员权限，只要你成功运行了该程序，就可以随时断开与该设备的连接。一般的，它的工作原理是检测设备和电脑同步所产生的备份文件，之后假装和设备建立了一个新的无线同步连接，并利用它来打开 ssh 端口，吧啦啦，告诉你一个秘密，因为eOS的用户拿到不到他们自己设备的终端权限，所有的管理员 admin 的密码都是一样的！密码是 alpine不用谢我，估计这能帮你省好几百万年的时间吧！我可是期待着拿到我们谈好的报酬哦～—vtfx\n\n登陆Entropy组织的资源服务器\n进入 bin 目录，scp eosDivceScan.exe，获取黑客工具\n\n\n\n\n\n\n\n\n\n\n找到你怀疑有eOS设备同步的电脑，并获取管理员权限运行 eos.exe，扫描已配对的设备，它会自动打开连接的端口连接到已列出的设备用户名 admin密码 alpine\n\n点击 Jason PowerBook Plus，点击 检测系统\n需要破解2个端口\n输入 sshcrack 22\n输入 ftpbounce 21\n输入 porthack ，破解成功，登录\n输入 eosdevicescan，扫描到 Jason 1Phone 4S\n登录Jason 1Phone 4S\n输入用户名 admin，输入密码 alpine\n登录成功，进入文件系统，进入 eos 目录\n在 mail 下找到邮箱密码\n账号 jjstacks@gmail.com\n密码 tintin7\n删除历史记录，回复邮件，完成任务\n\n接到第十八条黑客邮件：合同完成\n\n\n\n\n\n\n\n\n恭喜，你接受的任务已经完成，客户对你的工作很满意。你现在可以去数据库里随意接受其他任务了，你现在在100人中排名第19，谢谢。\n","slug":"Hacknet Walkthrough","date":"2022-11-13T06:50:48.000Z","categories_index":"Cyber Security","tags_index":"GOG Games","author_index":"Brandon"},{"id":"7ffde49d34885cb79e15d49bc1c3d82b","title":"Kunjing — HBU Competition","content":"坤竞——HBU竞赛组队匹配系统介绍：帮助河北大学师生营造更好的竞赛氛围，找到志同道合的伙伴，移动端 H5 网页（尽量兼容 PC 端），后续可加入科研方面。\n测试v1.0.0：http://kunjing.brandon777.com（未导入数据，前后端接口暂未接入）\n1 需求分析​        根据标签进行用户匹配，如：\n\n\n\n\n\n\n\n\n\n性别：男、女\n专业：软件工程、网络安全 ···\n正在准备/研究/进行：挑战杯、互联网+、大创、数模、蓝桥杯、CTF ···\n目标：挑战杯、互联网+、大创、数模、蓝桥杯、CTF ···\n（最高获奖）等级：未获奖、校级、省级、国家级\n身份：大一、大二、大三、大四、研一、研二、研三、博士、副教授、教授、企业\n\n用户信息\n支持Excel导入学生教务信息（模拟字段）√\n用户去添加/修改标签，标签的分类（要有哪些标签、怎么把标签进行分类）学习方向 挑战杯 / 互联网+ / 大创 ···（未开发完全）\n\n\n科研组队/竞赛组队\n创建队伍 √\n加入队伍 √\n解散队伍 √\n在线聊天（未开发)\n一起教室自习（接入智慧教务可视化）\n邀请其他人（未开发）\n\n\n查询搜索\n主动搜索：允许用户根据标签去搜索其他用户 √\nRedis 缓存 √\n\n\n根据标签查询队伍 √\n\n\n推荐匹配\n匹配标签相似学生 √\n匹配指导教师 √\n匹配公司投资 √\n相似度计算算法 + 本地分布式计算 √\n\n\n\n2 技术选型2.1 前端\nVue 3 开发框架（提高页面开发的效率）\nTypeScript（JavaScript 增强版）\nVant UI（基于 Vue 的移动端组件库）（React 版 Zent）\nVite 3（打包工具，快！）\nNginx 来单机部署\n\n2.2 后端\nJava 编程语言 + SpringBoot 框架\nSpringMVC + MyBatis + MyBatis Plus（提高开发效率）\nMySQL 数据库\n分布式 Session 登录\n数据查询 Redis 缓存\n缓存预热—定时任务\n控制定时任务—锁 + 分布式锁\nSwagger + Knife4j 接口文档\n\n3 数据库表设计及选择create\ndatabase if not exists kunjing;\n\nuse\nkunjing;\n3.1 用户表 user3.1.1 字段阐释\n\n\n\n字段\n名称\n类型\n\n\n\n\nid\n用户 id\nbigint\n\n\nusername\n昵称\nvarchar\n\n\nuserAccount\n登录账号\nvarchar\n\n\navatarUrl\n用户头像\nvarchar\n\n\ngender\n性别\ntinyint\n\n\nuserPassword\n密码\nvarchar\n\n\nprofile\n个人简介\nvarchar\n\n\nphone\n电话\nvarchar\n\n\nemail\n邮箱\nvarchar\n\n\nuserStatus\n状态 0 - 正常 1 - 封号\nint\n\n\ncreateTime\n创建时间\ndatetime\n\n\nupdateTime\n更新时间\ndatetime\n\n\nisDelete\n是否删除\ntinyint\n\n\nuserRole\n用户角色 0 - 普通用户 1 - 管理员\nint\n\n\nplanetCode\n星球编号\nvarchar\n\n\ntags\n标签 json 列表\nvarchar\n\n\n\n\n3.1.2 建表语句create table user\n(\n    username     varchar(256)                       null comment &#39;用户昵称&#39;,\n    id           bigint auto_increment              comment &#39;id&#39; primary key,\n    userAccount  varchar(256)                       null comment &#39;账号&#39;,\n    avatarUrl    varchar(1024)                      null comment &#39;用户头像&#39;,\n    gender       tinyint                            null comment &#39;性别&#39;,\n    userPassword varchar(512)                       not null comment &#39;密码&#39;,\n    profile      varchar(512)                       null comment &#39;个人简介&#39;,\n    phone        varchar(128)                       null comment &#39;电话&#39;,\n    email        varchar(512)                       null comment &#39;邮箱&#39;,\n    userStatus   int      default 0                 not null comment &#39;状态 0 - 正常&#39;,\n    createTime   datetime default CURRENT_TIMESTAMP null comment &#39;创建时间&#39;,\n    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,\n    isDelete     tinyint  default 0                 not null comment &#39;是否删除&#39;,\n    userRole     int      default 0                 not null comment &#39;用户角色 0 - 普通用户 1 - 管理员&#39;,\n    planetCode   varchar(512)                       null comment &#39;星球编号&#39;,\n    tags         varchar(1024)                      null comment &#39;标签 json 列表&#39;\n)\n    comment &#39;用户&#39;;\n3.2 队伍表 team3.1.1 字段阐释\n\n\n\n字段\n名称\n类型\n作用\n\n\n\n\nid\n主键\nbigint\n最简单、连续，放 url 上比较简短，但缺点是爬虫\n\n\n\n\n3.1.2 建表语句create table team\n(\n    id              bigint auto_increment               comment &#39;id&#39; primary key,\n    name            varchar(256)                        not null comment &#39;队伍名称&#39;,\n    avatarUrl       varchar(1024)                       null comment &#39;用户头像&#39;,\n    description     varchar(1024)                       null comment &#39;描述&#39;,\n    maxNum          int      default 1                  not null comment &#39;最大人数&#39;,\n    expireTime      datetime                            null comment &#39;过期时间&#39;,\n    userId          bigint                              comment &#39;用户id&#39;,\n    status          int      default 0                  not null comment &#39;0 - 公开，1 - 私有，2 - 加密&#39;,\n    password        varchar(512)                        null comment &#39;密码&#39;,\n    createTime      datetime default CURRENT_TIMESTAMP  null comment &#39;创建时间&#39;,\n    updateTime      datetime default CURRENT_TIMESTAMP  null on update CURRENT_TIMESTAMP,\n    isDelete        tinyint  default 0                  not null comment &#39;是否删除&#39;\n)\n    comment &#39;队伍&#39;;\n3.3 用户-队伍表 user_team3.1.1 字段阐释3.1.2 建表语句create table user_team\n(\n    id              bigint auto_increment               comment &#39;id&#39; primary key,\n    userId          bigint                              comment &#39;用户id&#39;,\n    teamId          bigint                              comment &#39;队伍id&#39;,\n    joinTime        datetime                            null comment &#39;加入时间&#39;,\n    createTime      datetime default CURRENT_TIMESTAMP  null comment &#39;创建时间&#39;,\n    updateTime      datetime default CURRENT_TIMESTAMP  null on update CURRENT_TIMESTAMP,\n    isDelete        tinyint  default 0                  not null comment &#39;是否删除&#39;\n)\n    comment &#39;用户队伍关系&#39;;\n两个关系：\n\n用户加了哪些队伍？\n队伍有哪些用户？\n\n方式：\n\n建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）\n用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）\n\n3.4 标签表（分类表）（并未选择）使用标签比分类更灵活。\n3.4.1 字段阐释\n\n\n\n字段\n名称\n类型\n作用\n\n\n\n\nid\n主键\nint\n\n\n\ntagName\n标签名\nvarchar\n非空（必须唯一，唯一索引）\n\n\nuserId\n上传标签的用户\nint\n如果要根据 userId 查已上传标签的话，最好加上，普通索引\n\n\nparentId\n父标签 id\nint\n查询所有标签，并且把标签分好组：按父标签 id 分组\n\n\nisParent\n是否为父标签\ntinyint\n0 - 不是父标签、1 - 父标签\n\n\ncreateTime\n创建时间\ndatetime\n\n\n\nupdateTime\n更新时间\ndatetime\n\n\n\nisDelete\n是否删除\ntinyint\n0、1\n\n\n\n\n3.4.2 建表语句create table tag\n(\n    id\t\t\tbigint auto_increment comment &#39;id&#39;  primary key,\n    tagName\t\tvarchar(256)\t\t\t\t\t\tnull comment &#39;标签名称&#39;,\n    userId\t\tbigint\t\t\t\t\t\t\t\tnull comment &#39;用户id&#39;,\n    parentId\tbigint\t\t\t\t\t\t\t\tnull comment &#39;父标签id&#39;,\n    isParent\ttinyint\t\t\t\t\t\t\t\tnull comment &#39;0 - 不是父标签，1 - 父标签&#39;,\n    createTime\tdatetime default CURRENT_TIMESTAMP\tnull comment &#39;创建时间&#39;,\n    updateTime\tdatetime default CURRENT_TIMESTAMP\tnull on update CURRENT_TIMESTAMP,\n    isDelete\ttinyint  default 0\t\t\t\t\tnot null comment &#39;是否删除&#39;,\n    constraint uniIdx_tagName unique (tagName)\n)\n    comment &#39;标签&#39;;\ncreate index idx_userId on tag (userId);\n3.5 查询方法由于数据量并不大仅为万级，故本项目选择第一种\n\n直接在用户表补充 tags 字段，[‘挑战杯’, ‘男’] 存 json 字符串  \n\n优点：查询方便、不用新建关联表，标签是用户的固有属性（除了该系统、其他系统可能要用到）节省开发成本\n查询用户列表，查关系表拿到这 100 个用户有的所有标签 id，再根据标签 id 去查标签表。\n哪怕性能低，可以用缓存。\n缺点：用户表多一列，会有冗余。\n\n\n加一个关联表，记录用户和标签的关系\n关联表的应用场景：查询灵活，可以正查反查\n缺点：要多建一个表、多维护一个表\n重点：企业大项目开发中尽量减少关联查询，很影响扩展性，而且会影响查询性能\n\n\n\n4 前端项目初始化4.1 前端引入用脚手架初始化项目\n\nVue CLI https://cli.vuejs.org/zh/\nVite 脚手架 ：https://vitejs.cn/guide/#scaffolding-your-first-vite-project\n\n整合组件库 Vant：\n\n安装 Vant npm i vant\n// Vant 2 按需引入 npm i vite-plugin-style-import@1.4.1 -D\nVant 3 按需引入插件 npm i unplugin-vue-components -D\n\n4.2 前端主页设计\n导航条：展示当前页面名称\n\n主页搜索框 =&gt; 搜索页 =&gt; 搜索结果页（标签筛选页）\n\n内容\n\ntab 栏：\n\n主页（推荐页 + 广告 ）\n\n搜索框\nbanner\n推荐信息流\n\n\n队伍页\n\n用户页（消息 - 暂时考虑发邮件）\n\n\n\n\n4.3 前端整合路由\nVue-Router：https://router.vuejs.org/zh/guide/#html，直接看官方文档引入\nVue-Router 根据不同的 url 来展示不同的页面（组件），不用自己写 if / else\n路由配置影响整个项目，建议单独用 config 目录、单独的配置文件去集中定义和管理。\n有些组件库可能自带了和 Vue-Router 的整合，所以尽量先看组件文档、省去自己写的时间。\n\n4.4 前端页面跳转传值\nquery =&gt; url searchParams，url 后附加参数，传递的值长度有限\nvuex（全局状态管理），搜索页将关键词塞到状态中，搜索结果页从状态取值\n\n4.5 前端不同页面传递数据\nurl querystring（xxx?id=1） 比较适用于页面跳转\nurl（/team/:id，xxx/1）\nhash (/team#1)\nlocalStorage\ncontext（全局变量，同页面或整个项目要访问公共变量）\n\n5 开发后端接口5.1 搜索标签\n允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%挑战杯%’ and like ‘%互联网+%’。\n允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%挑战杯%’ or like ‘%互联网+%’\n\n两种方式：\n\nSQL 查询（实现简单，可以通过拆分查询进一步优化）\n内存查询（灵活，可以通过并发进一步优化）\n\n\n如果参数可以分析，根据用户的参数去选择查询方式，比如标签数\n\n如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁。\n\n还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag\n\n可通过实际测试来分析哪种查询比较快，数据量大的时候验证效果更明显。\n5.2 解析 JSON 字符串\n序列化：java对象转成 json\n反序列化：把 json 转为 java 对象\n\njava  json 序列化库：\n\ngson（google 的）\n\nfastjson alibaba（ali 出品，快，但是漏洞太多）\n\njackson\n\nkryo\n\n\n5.2 用户中心整合用户中心（http://www.brandon777.com)来集中提供用户的检索、操作、注册、登录、鉴权\n\n前端整合路由\n前端开发（搜索页面、用户信息页、用户信息修改页）\n后端整合 Swagger + Knife4j 接口文档 \n存量用户信息导入及同步（爬虫或导入Excel）\n\n5.3 后端整合 Swagger + Knife4j 接口文档5.3.1 接口文档说明什么是接口文档？写接口信息的文档，每条接口包括：\n\n请求参数\n响应参数\n错误码\n\n\n接口地址\n接口名称\n请求类型\n请求格式\n备注\n\n5.3.2 接口文档作用\n有个书面内容（背书或者归档），便于大家参考和查阅，便于 沉淀和维护 ，拒绝口口相传\n接口文档便于前端和后端开发对接，前后端联调的 介质 。后端 =&gt; 接口文档 &lt;= 前端\n好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发测试效率\n\n5.3.3 接口文档实现\n手写（比如腾讯文档、Markdown 笔记）\n自动化接口文档生成：自动根据项目代码生成完整的文档或在线调试的网页。Swagger，Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国产）\n\n5.3.4 接口文档技巧Swagger 原理：\n\n引入依赖（Swagger 或 Knife4j：https://doc.xiaominfo.com/knife4j/documentation/get_start.html）\n自定义 Swagger 配置类\n定义需要生成接口文档的代码位置（Controller）\n千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 @Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;) 限定配置仅在部分环境开启\n启动即可\n可以通过在 controller 方法上添加 @Api、@ApiImplicitParam(name = “name”,value = “姓名”,required = true)    @ApiOperation(value = “向客人问好”) 等注解来自定义生成的接口描述信息\n\n如果 springboot version &gt;= 2.6，需要添加如下配置：\nspring:\n  mvc:\n  \tpathmatch:\n      matching-strategy: ANT_PATH_MATCHER\n5.4 模拟教务学生信息\n从 excel 中导入全量用户数据，判重 。 easy excel：https://alibaba-easyexcel.github.io/index.html\n抓取写了自我介绍的同学信息，提取出用户昵称、用户唯一 id、自我介绍信息\n从自我介绍中提取信息，然后写入到数据库中\n\nEasy Excel\n两种读对象的方式：\n\n确定表头：建立对象，和表头形成映射关系\n不确定表头：每一行数据映射为 Map\n\n两种读取模式：\n\n监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。\n同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。\n\n6 Session 共享\n单机登录改为分布式 session 登录。\n种 session 的时候注意范围，cookie.domain\n比如两个域名：\naaa.brandon777.com\nbbb.brandon777.com\n\n\n如果要共享 cookie，可以种一个更高层的公共域名，比如 brandon777.com\n\n6.1 Session 共享存储\n服务器 A 登录后，请求发到服务器 B，不认识该用户。\n用户在 A 登录，所以 session（用户登录信息）存在了 A 上\n结果请求 B 时，B 没有用户信息，所以不认识。\n\n\n\n解决方案：共享存储 ，而不是把数据放到单台服务器的内存中\n\n\n6.2 Session 共享实现6.2.1 原理如何共享存储？\n\nRedis（基于内存的 K / V 数据库）此处选择 Redis，因为用户信息读取 / 是否登录的判断极其频繁 ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w\nMySQL \n文件服务器 ceph\n\n6.2.2 实现\n安装 Redis\n官网：https://redis.io/\nredis 管理工具 quick redis：https://quick123.net/\n\n\n\n引入 redis，能够操作 redis：\n\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-data-redis --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：\n\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.session&#x2F;spring-session-data-redis --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n修改 spring-session 存储配置 spring.session.store-type\n默认是 none，表示存储在单台服务器\nstore-type: redis，表示从 redis 读写 session\n\n\n\nJWT 的优缺点：https://zhuanlan.zhihu.com/p/108999941\n\n7 主页开发\n最简单：直接 list 列表\n模拟 100 万个用户，再去查询\n\n7.1 导入数据\n用可视化界面：适合一次性导入、数据量可控\n\n写程序：for 循环，分批写入（可以用接口来控制）要保证可控、幂等，注意线上环境和测试环境是有区别的\n导入 1000 万条，for i 100w\n\n执行 SQL 语句：适用于小数据量\n\n\n7.2 编写一次性任务for 循环插入数据的问题：\n\n建立和释放数据库链接（批量查询解决）\nfor 循环是绝对线性的（并发）\n\n\n并发要注意执行的先后顺序无所谓，不要用到非并发类的集合\n\nprivate ExecutorService executorService &#x3D; new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(10000));\n&#x2F;&#x2F; CPU 密集型：分配的核心线程数 &#x3D; CPU - 1\n&#x2F;&#x2F; IO 密集型：分配的核心线程数可以大于 CPU 核数\n\n数据库慢可预先把数据查出来，放到一个更快读取的地方，不用再查数据库了。（缓存）\n预加载缓存，定时更新缓存。（定时任务）\n分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了\n\n8 数据查询慢-缓存用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快地读写。\n8.1 缓存的实现\nRedis（分布式缓存）\nmemcached（分布式）\nEtcd（云原生架构的一个分布式存储，存储配置，扩容能力）\n\n\n\nehcache（单机）\n\n本地缓存（Java 内存 Map）\n\nCaffeine（Java 内存缓存，高性能）\nGoogle Guava\n\n8.2 Redis\n\n\n\n\n\n\n\n\nNoSQL 数据库\n\nkey - value 存储系统（区别于 MySQL，他存储的是键值对）\n\n8.2.1 Redis 数据结构\nString 字符串类型： name: “Brandon”\nList 列表：names: [“Brandon”, “Sarbr”, “Brandon”]\nSet 集合：names: [“Brandon”, “Sarbr”]（值不能重复）\nHash 哈希：nameAge: {  “Brandon”: 1, “Sarbr”: 2 }\nZset 集合：names: {  Brandon- 9,   Sarbr- 12  }（适合做排行榜）\n\n\n\nbloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）\ngeo（计算地理位置）\nhyperloglog（pv / uv）\npub / sub（发布订阅，类似消息队列）\nBitMap （1001010101010101010101010101）\n\n8.2.2 自定义序列化package com.brandon.kunjing.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.RedisSerializer;\n\n@Configuration\npublic class RedisTemplateConfig &#123;\n\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;\n        RedisTemplate&lt;String, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;();\n        redisTemplate.setConnectionFactory(connectionFactory);\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        return redisTemplate;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n引入一个库时，先写测试类\n8.3 Java 里的实现方式8.3.1 Spring Data Redis（推荐）Spring Data：通用的数据访问框架，定义了一组 增删改查 的接口\nmysql、redis、jpa\nspring-data-redis\n1）引入\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n2）配置 Redis 地址\nspring:\n  # redis 配置\n  redis:\n    port: 6379\n    host: localhost\n    database: 0\n8.3.2 Jedis\n独立于 Spring 操作 Redis 的 Java 客户端\n要配合 Jedis Pool 使用\n\n8.3.3 Lettuce\n高阶 的操作 Redis 的 Java 客户端\n异步、连接池\n\n8.3.4 Redisson\n分布式操作 Redis 的 Java 客户端，像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）\n\n8.3.5 JetCache对比\n\n如果项目用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便\n如果项目用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool\n如果项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池\n\n8.4 设计缓存 key\n不同用户看到的数据不同\nsystemId:moduleId:func:options（不要和别人冲突）\nkunjing:user:recommed:userId\n\nredis 内存不能无限增加，一定要设置过期时间。\n8.5 缓存预热问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库\n8.5.1 优缺点\n缓存预热的优点：\n\n解决上面的问题，可以让用户始终访问很快\n\n\n\n\n缺点：\n\n增加开发成本（你要额外的开发、设计）\n预热的时机和时间如果错了，有可能你缓存的数据不对或者太老\n需要占用额外空间\n\n\n\n8.5.2 缓存预热\n定时\n模拟触发（手动触发）\n\n8.5.3 实现\n用定时任务，每天刷新所有用户的推荐列表\n注意点：\n缓存预热的意义（新增少、总用户多）\n缓存的空间不能太大，要预留给其他缓存空间\n缓存数据的周期（此处每天一次）\n\n\n\n9 缓存预热—定时任务\nSpring Scheduler（spring boot 默认整合了） \nQuartz（独立于 Spring 存在的定时任务框架）\nXXL-Job 之类的分布式任务调度平台（界面 + sdk）\n\n\n第一种方式：\n\n主类开启 @EnableScheduling\n给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率\n\n\n\n\n不必背 cron 表达式。\nhttps://cron.qqe2.com/\nhttps://www.matools.com/crontab/\n\n\n9.1 控制定时任务的执行\n浪费资源，想象 10000 台服务器同时 “打鸣”\n脏数据，比如重复插入\n\n\n要控制定时任务在同一时间只有 1 个服务器能执行。\n\n\n分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大\n\n写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低；但是我们的 IP 可能是不固定的，把 IP 写的太死了\n\n动态配置，配置是可以轻松的、很方便地更新的（代码无需重启），但是只有 ip 符合配置的服务器才真实执行业务逻辑。\n\n数据库\nRedis\n配置中心（Nacos、Apollo、Spring Cloud Config）\n\n问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改\n\n分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。\n\n\n\n单机就会存在单点故障。\n\n10 控制定时任务—锁\n有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。\nJava 实现锁：synchronized 关键字、并发包的类\n问题：只对单个 JVM 有效\n\n10.1 分布式锁\n有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。\n单个锁只对单个 JVM 有效\n\n10.2 分布式锁实现的关键10.2.1 抢锁机制\n保证同一时间只有 1 个服务器能抢到锁 核心思想 ：\n先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。\n等先来的人执行方法结束，把标识清空，其他的人继续抢锁。\n\n\nMySQL 数据库：select for update 行级锁（最简单）（乐观锁）\nRedis 实现：内存数据库，读写速度快 。支持 setnx、lua 脚本，比较方便我们实现分布式锁。\nsetnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false\n\n\n\n10.2.2 注意事项\n用完锁要释放（腾地方）√\n\n锁一定要加过期时间 √\n\n如果方法执行时间过长，锁提前过期了？\n问题：\n\n连锁效应：释放掉别人的锁\n这样还是会存在多个方法同时执行的情况\n\n\n\n​    解决方案：续期\nboolean end &#x3D; false;\n\nnew Thread(() -&gt; &#123;\n    if (!end)&#125;&#123;\n    续期\n&#125;)\n\nend &#x3D; true;\n\n\n释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁\n&#x2F;&#x2F; 原子操作\nif(get lock &#x3D;&#x3D; A) &#123;\n    &#x2F;&#x2F; set lock B\n    del lock\n&#125;\nRedis + lua 脚本实现\n\nRedis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？\n\n\nhttps://blog.csdn.net/feiying0canglang/article/details/113258494\n10.3 Redisson 实现分布式锁\nJava 客户端，数据网格\n实现了很多 Java 里支持的接口和数据结构\nRedisson 是一个 java 操作 Redis 的客户端，提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。\n\n10.3.1 2 种引入方式\nspring boot starter 引入（不推荐，版本迭代太快，容易冲突）https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter\n直接引入：https://github.com/redisson/redisson#quick-start\n\n示例代码&#x2F;&#x2F; list，数据存在本地 JVM 内存中\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;Brandon&quot;);\nSystem.out.println(&quot;list:&quot; + list.get(0));\n\nlist.remove(0);\n\n&#x2F;&#x2F; 数据存在 redis 的内存中\nRList&lt;String&gt; rList &#x3D; redissonClient.getList(&quot;test-list&quot;);\nrList.add(&quot;Brandon&quot;);\nSystem.out.println(&quot;rlist:&quot; + rList.get(0));\nrList.remove(0);\n10.4 定时任务  + 锁\nwaitTime 设置为 0，只抢一次，抢不到就放弃\n注意释放锁要写在 finally 中\n\n10.4.1 实现代码void testWatchDog() &#123;\n    RLock lock &#x3D; redissonClient.getLock(&quot;kunjing:precachejob:docache:lock&quot;);\n    try &#123;\n        &#x2F;&#x2F; 只有一个线程能获取到锁\n        if (lock.tryLock(0, -1, TimeUnit.MILLISECONDS)) &#123;\n            &#x2F;&#x2F; todo 实际要执行的方法\n            doSomeThings();\n            System.out.println(&quot;getLock: &quot; + Thread.currentThread().getId());\n        &#125;\n    &#125; catch (InterruptedException e) &#123;\n        System.out.println(e.getMessage());\n    &#125; finally &#123;\n        &#x2F;&#x2F; 只能释放自己的锁\n        if (lock.isHeldByCurrentThread()) &#123;\n            System.out.println(&quot;unLock: &quot; + Thread.currentThread().getId());\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n10.4.2 看门狗机制\n\n\n\n\n\n\n\n\nredisson 中提供的续期机制\n开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。\n原理：\n\n监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）\n如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期\n\nhttps://blog.csdn.net/qq_26222859/article/details/79645203\n\nZookeeper 实现（不推荐）\n11 组队功能11.1 理想的应用场景和别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍。\n11.2 需求分析\n用户可以 创建 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0\n\n\n\n\n\n\n\n\n\n\n队长、剩余的人数\n聊天？\n公开 或 private 或加密\n用户创建队伍最多 5 个\n\n展示队伍列表，根据名称搜索队伍  P0，信息流中不展示已过期的队伍\n\n\n修改队伍信息 P0 ~ P1\n\n\n用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限  P0\n\n\n\n\n\n\n\n\n\n\n是否需要队长同意？筛选审批？\n\n用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 —— 先来后到） P1\n\n\n队长可以解散队伍 P0\n\n\n\n分享队伍 =》 邀请其他用户加入队伍 P1\n\n\n业务流程：\n\n生成分享链接（分享二维码）\n用户访问链接，可以点击加入\n\n\n队伍人满后发送消息通知 P1\n\n\n11.3 系统（接口）设计11.3.1 创建队伍用户可以 创建 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0\n\n\n\n\n\n\n\n\n\n队长、剩余的人数\n聊天？\n公开 或 private 或加密\n信息流中不展示已过期的队伍\n\n请求参数是否为空？\n是否登录，未登录不允许创建\n校验信息\n队伍人数 &gt; 1 且 &lt;= 20\n队伍标题 &lt;= 20\n描述 &lt;= 512\nstatus 是否公开（int）不传默认为 0（公开）\n如果 status 是加密状态，一定要有密码，且密码 &lt;= 32\n超时时间 &gt; 当前时间\n校验用户最多创建 5 个队伍\n\n\n插入队伍信息到队伍表\n插入用户  =&gt; 队伍关系到关系表\n\n11.3.2 查询队伍列表分页展示队伍列表，根据名称、最大人数等搜索队伍  P0，信息流中不展示已过期的队伍\n\n从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件\n不展示已过期的队伍（根据过期时间筛选）\n可以通过某个关键词同时对名称和描述查询\n只有管理员才能查看加密还有非公开的房间\n关联查询已加入队伍的用户信息\n关联查询已加入队伍的用户信息（可能会很耗费性能，建议大家用自己写 SQL 的方式实现）\n\n实现方式\n1）自己写 SQL\n&#x2F;&#x2F; 1. 自己写 SQL\n&#x2F;&#x2F; 查询队伍和创建人的信息\nselect * from team t left join user u on t.userId &#x3D; u.id\n&#x2F;&#x2F; 查询队伍和已加入队伍成员的信息\nselect *\nfrom team t\n       left join user_team ut on t.id &#x3D; ut.teamId\n       left join user u on ut.userId &#x3D; u.id;\n11.3.3 修改队伍信息\n判断请求参数是否为空\n查询队伍是否存在\n只有管理员或者队伍的创建者可以修改\n如果用户传入的新值和老值一致，就不用 update 了（可自行实现，降低数据库使用次数）\n如果队伍状态改为加密，必须要有密码\n更新成功\n\n11.3.4 用户可以加入队伍其他人、未满、未过期，允许加入多个队伍，但是要有个上限  P0\n\n用户最多加入 5 个队伍\n队伍必须存在，只能加入未满、未过期的队伍\n不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）\n禁止加入私有的队伍\n如果加入的队伍是加密的，必须密码匹配才可以\n新增队伍 - 用户关联信息\n\n11.3.5 用户可以退出队伍请求参数：队伍 id\n\n校验请求参数\n\n校验队伍是否存在\n\n校验我是否已加入队伍\n\n如果队伍\n\n只剩一人，队伍解散\n\n还有其他人\n\n如果是队长退出队伍，权限转移给第二早加入的用户 —— 先来后到\n\n\n\n\n\n\n\n\n\n只用取 id 最小的 2 条数据\n\n非队长，自己退出队伍\n\n\n\n\n\n\n11.3.6 队长可以解散队伍请求参数：队伍 id\n业务流程：\n\n校验请求参数\n校验队伍是否存在\n校验你是不是队伍的队长\n移除所有加入队伍的关联信息\n删除队伍\n\n11.4 事务注解@Transactional(rollbackFor = Exception.class)\n事务回滚，要么数据操作都成功，要么都失败。\n11.5 请求参数包装类\n请求参数名称 / 类型和实体类不一样\n\n有一些参数用不到，如果要自动生成接口文档，会增加理解成本\n\n对个实体类映射到同一个对象\n\n\n11.5.1 包装类作用\n可能有些字段需要隐藏，不能返回给前端\n\n\n或者有些字段某些方法是不关心的\n\n11.6 数据查询可分表\nmycat、sharding sphere 框架\n一致性 hash\n\n11.7 队伍操作权限控制\n加入队伍： 仅非队伍创建人、且未加入队伍的人可见\n更新队伍：仅创建人可见\n解散队伍：仅创建人可见\n退出队伍：创建人不可见，仅已加入队伍的人可见\n\n12 随机匹配更快地匹配自己兴趣相同的队友\n12.1 匹配原理\n匹配多个，并且按照匹配的相似度从高到低排序、\n根据标签 tags 匹配\n还可以根据 user_team 匹配加入相同队伍的用户\n\n\n\n\n\n\n\n\n\n\n本质：找到有相似标签的用户\n举例：\n用户 A：[Java, 大一, 男]\n用户 B：[Java, 大二, 男]\n用户 C：[Python, 大二, 女]\n用户 D：[Java, 大一, 女]\n\n找到有共同标签最多的用户（TopN）\n共同标签越多，分数越高，越排在前面\n如果没有匹配的用户，随机推荐几个（降级方案）\n\n12.2 匹配算法编辑距离算法：https://blog.csdn.net/DBC_121/article/details/104198838\n\n\n\n\n\n\n\n\n\n最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2\n余弦相似度算法：https://blog.csdn.net/m0_55613022/article/details/125683937（如果需要带权重计算，比如学什么方向最重要，性别相对次要）\n12.3 匹配实现\n直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）\n\n优化方法：\n\n切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒）\n\nMap 存了所有的分数信息，占用内存\n解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）\ne.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了\n\n细节：剔除自己 √\n\n尽量只查需要的数据：\n\n过滤掉标签为空的用户 √\n根据部分标签取用户（前提是能区分出来哪个标签比较重要）\n只查需要的数据（比如 id 和 tags） √（7.0s）\n\n\n提前查？（定时任务）\n\n提前把所有用户给缓存（不适用于经常更新的数据）\n提前运算出来结果，缓存（针对一些重点用户，提前缓存）\n\n\n\n\n大数据推荐不需要查出所有用户及相似度。\n检索 =&gt; 召回 =&gt; 粗排 =&gt; 精排 =&gt; 重排序等等。\n\n检索：尽可能多地查符合要求的数据（比如按记录查）\n召回：查询可能要用到的数据（不做运算）\n粗排：粗略排序，简单地运算（运算相对轻量）\n精排：精细排序，确定固定排位\n\n\n\n13 遇到问题及解决\n组件化思想：很多页面要复用组件 / 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）\n查询所有标签并分组：按父标签 id 分组\n根据父标签查询子标签：根据 id 查询\n内存查询与数据库查询优化\n优化主页性能：缓存 + 定时任务 + 分布式锁\n缓存 + 锁用完释放、设置过期时间\n前端加载骨架屏特效：van-skeleton 组件\n仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态）\n前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）\n在后端去做上述事情（推荐）\n\n\n前端导航栏死【标题】问题：使用 router.beforeEach，根据要跳转页面的 url 路径 匹配 config/routes 配置的 title 字段。\n强制登录，前端全局响应拦截，自动跳转到登录页\n加入有密码的房间，要指定密码\n分布式锁 导致的其他服务器数据不统一的问题或者多个 Redis 里的数据不一致。\n重复加入队伍的问题（加锁、分布式锁）并发请求时可能出现问题\n用户登录页跳转\n标签\n前端拦截器统一输出日志\n\n\nVant3 更新后配置 viteconfig 需要 npm 按需引入插件了，styleImport 变成了 Component，resolve 变成了 resolver，vite3 更新后还得单独引入 css，感觉越变越麻烦但确实降低了冗余\n\n\n项目初始化不小心混合了 Vant2 和 Vant3 unplugin-vue-components 再手动引入组件样式的按需引入插件和样式\n\n导入 Swagger + Knife4j 出现版本冲突，yml 开始没解析 ant_patch_matcher 也许有缓存\n\n\n\n\n\nmvnrepository中easyexcel3.1.0版本用不了了，idea2022.2database没有了\n\n共模拟1000000条数据，插入1000条3s，顺序执行批量导入0.8s，100000条17s，并发100000条10组5s ，20组、40组5s性能几乎无变化，可能与线程切换需要时间、数据库性能、CPU核数（CPU密集型线程数CPU核数-1，IO密集型线程数可以大于CPU核数）有关，不同情况需具体测试。\n\n\n\n\n\n\n\nredis timeout MILLISECONDS写成MICROSECONDS\n\n\n\nlombok只要改个pom就会找不到符号，找不到方法，勾选enable annotation processing基本没用，setting里build，compiler对VM options加上-Djs.track.ap.dependencies=false好用\n\n两个Long封装类不能用!=，最后抽离出两个变量转为long基本类型却可以使用!=。可能 Java 更新后 ==比较栈（内存中地址值），equals比较堆（两个对象的内容） \n\n\n\n\n\n\n前后端联调CORS协议现在CROSSORIGIN配置跨域还要配置安全证书(allowCredentials=true) \n\nWebStorm打包ts的时避免报错可以file，setting，file watcher配置Typescript，有的加的// @ts-ignore，有的加的any类型，或者给自己定义的.d.ts加上了变量，ts.config里面strict可以改成false。\n\n部署上线记得改前后端URL域名，端口。 \n\n\n","slug":"Kun Jing","date":"2022-10-05T09:01:36.000Z","categories_index":"Project","tags_index":"Project","author_index":"Brandon"},{"id":"d47a36c3a510133b5b347d3a187e7783","title":"Opertion System Outline","content":"0 前言0.1 前言\n基本概念、基本方法\n设计原理、实现方法\n形成、类型、功能\n进程管理、存储器管理、设备管理、文件管理\n网络操作系统、分布式操作系统\n\n0.2 内容\n背景知识\n\n基本概念、发展、特性、功能和结构设计\n硬件环境\n\n\n进程\n进程和线程的\n\n基本概念\n进程控制\n进程调度\n进程同步\n进程通信\n死锁\n\n\n存储管理\n\n概念和功能\n分区和页式存储管理\n虚拟页式存储器管理\n\n\n文件和输入/输出管理\n\n操作系统的用户接口管理\n文件管理的基本概念和功能\n设备管理的基本概念和功能\n\n\n网络与分布式系统\n\n网络操作系统\n分布式操作系统\n\n\n\n1 引论1.1 操作系统的概念\n计算机系统\n硬件（子）系统、软件（子）系统\n计算机系统的层次结构\n软件分类\n系统软件\n支撑软件\n应用软件\n\n\n\n\n操作系统简介\n操作系统的地位\n操作系统的定义\n操作系统的目标\n\n\n\n1.2 操作系统的形成与发展\n操作系统的形成\n单道批处理系统\n多道批处理系统\n分时系统\n实时系统\n操作系统的\n推动操作系统\n\n1.3 研究操作系统的几种观点\n软件的观点\n计算机系统资源管理的观点\n进程的观点\n用户与计算机硬件系统之间接口的观点\n虚拟机器观点\n服务提供者观点\n\n1.4 操作系统的功能与特征\n通用操作系统\n操作系统的功能\n处理机、存储器、设备、文件、用户接口\n\n\n操作系统的特征\n并发、共享、虚拟、异步性\n\n\n\n1.5 操作系统结构设计\n传统的操作系统结构\n模块化结构\n层次结构\n\n\n现代的操作系统结构\n微内核\n客户机 / 服务器模式\n\n\n\n2 操作系统的硬件环境2.1 中央处理机（CPU）\nCPU的构成与基本工作方式\n特权指令与非特权指令\n处理机的状态\n程序状态字PSW\n\n2.2 存储系统\n存储器类型\n存储器层次结构\n存储分块\n存储保护\n\n2.3 缓冲技术与中断技术\n缓冲技术\n中断技术\n概念\n分类\n组成部分\n基本功能\n中断逻辑与中断寄存器\n多级中断和中断屏蔽\n中断响应\n中断处理\n时钟\n\n\n\n3 进程与进程管理3.1 进程引入\n前趋图\n程序顺序执行\n程序并发执行\n多道程序设计\n必须解决的问题\n\n3.2 进程\n引入进程原因\n进程概念\n进程的基本状态和转换\n\n\n\n进程控制块PCB\n进程控制\n\n3.3 进程调度\n调度的基本概念\n功能\n调度方式\n\n\n进程调度算法\n先进先出（FIFO）算法\n最短处理机运行期优先调度算法\n最高响应比优先调度算法\n优先级调度算法\n时间片轮转调度算法\n前后台调度算法\n多级反馈队列轮转算法\n\n\n进程调度的时间和过程\n\n3.4 线程的基本概念\n线程的引入\n线程的定义和属性\n线程与进程的比较\n线程的实现机制\n用户级线程\n内核支持线程\n用户级和内核支持比较\n\n\n\n4 进程同步与通信4.1 进程间的相互作用\n进程间联系\n临界资源\n临界区\n同步机制应遵循的原则：空闲让进、忙则等待、优先等待、让权等待\n\n\n利用软件方法解决进程互斥问题\n利用硬件方法解决进程互斥问题\nTest-and-Set指令\nSwap指令\n\n\n信号量机制\n记录型：wait、signal\nAND型：swait、ssignal\n一般“信号量集”机制\n\n\n经典进程同步问题\n生产者-消费者问题\n读者-写者问题\n哲学家进餐问题\n嗜睡的理发师问题\n\n\n管程机制\n\n4.2 进程通信\n基本概念\n进程通信的类型\n共享存储器系统\n消息传递系统\n管道通信\n\n\n直接通信和间接通信\n消息缓冲队列\n\n4.3 死锁\n产生死锁的四个必要条件\n互斥条件\n请求和保持条件\n不剥夺条件\n环路等待条件\n\n\n预防死锁\n摒弃“请求和保持”条件\n摒弃“不剥夺”条件\n摒弃“环路等待”条件\n\n\n避免死锁\n安全与不安全状态\n银行家算法\n安全性算法\n\n\n检测死锁\n资源分配图\n死锁定理\n死锁检测中的数据结构\n\n\n解除死锁\n\n5 存储器管理5.1 概述\n存储体系\n存储管理目的\n存储管理任务\n程序的链接和装入\n各种存储管理方式\n\n5.2 连续存储管理方式\n单一连续分配\n分区分配\n固定分区\n可变分区\n\n\n\n5.3 覆盖技术与交换技术\n覆盖技术\n交换技术\n\n5.4 分页存储管理方式\n工作原理\n动态地址变换\n快表\n两级和多级页表\n分配与回收\n\n5.5 分段存储管理方式\n基本思想（工作原理）\n动态地址变换\n分页和分段的主要区别\n\n5.6 段页式存储管理方式\n基本原理\n地址变换\n\n6 虚拟存储器管理6.1 概述\n局部性原理\n虚拟存储器特征\n虚拟存储器定义\n\n6.2 分页虚拟存储管理\n基本原理\n缺页中断结构\n地址变换结构\n页面置换算法\n内存分配策略和分配算法\n最小物理块数\n物理块的分配策略\n物理块分配算法\n调页策略\n\n\n抖动问题\n\n6.3 分段虚拟存储管理\n基本原理\n缺段中断结构\n段的动态链接\n段的共享\n\n7 用户接口管理7.1 概述\n命令接口\n程序接口\n图形接口\n\n7.2 命令接口\n联机命令接口\n命令的格式和分类\n终端处理程序\n命令解释程序\n\n\n脱机命令接口\n\n7.3 系统调用\n概念\n系统调用分类\n系统调用与一般过程调用的区别\n\n\n处理过程\n基本概念\n系统调用的执行过程大体上分成以下三步\n\n\n\n8 文件管理8.1 概述\n文件和文件系统\n文件的分类\n\n8.2 文件的结构和存取方式\n文件的存取方式\n文件的逻辑结构\n存储介质\n文件的物理结构\n\n8.3 文件目录\n文件目录管理应达到的要求\n文件控制块\n文件目录结构\n目录查找和改进\n\n8.4 文件系统的实现\n打开文件表\n外存空间管理\n\n8.5 文件的使用\n主要操作\n文件共享\n\n8.6 文件系统的安全性和数据一致性\n影响文件安全性主要因素\n防止人为因素造成的文件不安全性\n隐蔽文件和目录\n口令\n文件加密\n制定访问权限\n\n\n防止系统因素或自然因素造成的文件不安全性\n坏块管理\n磁盘容错技术\n备份\n\n\n文件系统的数据一致性\n块的一致性检查\n文件一致性检查\n\n\n\n8.7 磁盘调度\n先来先服务（FCFS）算法\n最短查找时间优先（SSTF）算法\n扫描算法\n电梯调度算法\n循环扫描策略\nN步扫描策略\nFSCAN算法\n\n\n磁盘的优化分布\n\n8.8 Linux 文件系统\nLinux 文件系统结构\nLinux 文件类型\nLinux 文件系统目录\nLinux 文件查找\nLinux 文件操作\nLinux 文件共享\nLinux 文件目录操作\nLinux 文件一致性处理\nLinux EXT2 文件系统\nEXT2 位示图和 I 节点图\nLinux 高速缓存\n\n9 设备管理9.1 概述\n设备的分类\n\n设备管理目标\n\n设备管理任务\n\n监视所有设备的状态\n\n\n\n制定设备分配策略\n设备的分配\n设备的回收\n\n\n\n9.2 I/O硬件特点\n设备组成\n设备接口\n设备控制器\n通道\nI/O 控制方式\n缓冲技术\n缓冲池\n\n9.3 I/O软件组成\nI/O 软件目标\n中断处理程序\n设备驱动程序\n独立于设备的软件\n用户空间的 I/O 软件\n\n9.4 设备分配\n设备分配中的数据结构\n设备独立性\n设备分配\n\n9.5 虚拟设备\nSpooling 技术\n共享打印机\n\n10 网络服务器与分布式系统10.1 分布式系统概述\n分布式能力\n\n通信结构\n\n开放式系统互连通信结构\nOSI七层模型\n\n物理层\n数据链路层\n网络层\n传输层\n会话层\n表示层\n应用层\n\n\n\n10.2 网络服务器\n服务器结构\n磁盘和文件服务器\n文件服务器\n磁盘服务器\n打印机服务器\n调制解调器服务器\n\n\n\n10.3 分布式进程管理\n分布式互斥\n集中式算法\n分布式算法\n克服时钟同步困难：事件定序法\n\n\n分布式算法\nLamport 分布式算法\n令牌传递法\n\n\n\n10.4 进程迁移\n进程迁移\n进程迁移机制\n迁移处理\n\n10.5 分布式进程通信\n信息传送机制\n远程过程调用\n确定分布式系统的全局状态\n全局状态和分布式瞬态\n分布式瞬态算法\n\n\n\n10.6 分布式进程同步与互斥\n事件定序法\n\n集中式算法\n\n分布式算法\n\n\nLamport 分布式算法\n\n\n令牌传递法\n\n\n10.7 分布式进程死锁问题\n资源分配中的死锁\n死锁的预防\n死锁的检测\n系统是集中式的控制\n分层控制\n分布式控制\n\n\n\n\n消息通信中的死锁\n相互等待\n消息死锁和资源死锁的区别\n破坏死锁方法：预防或检测\n\n\n没有空闲可用的消息缓冲区\n直接存储转发死锁\n间接存储转发死锁\n\n\n\n\n\n","slug":"Operation System Outline","date":"2022-10-03T09:01:36.000Z","categories_index":"Opertion System","tags_index":"Opertion System","author_index":"Brandon"},{"id":"6c60290e7688a2cab83459ffd68eb546","title":"1 计算机系统概论","content":"0 导读 脉冲信号\n\n\n\n\n\n1 计算机的分类1.1 电子计算机\n电子模拟计算机\n“模拟”就是相似的意思。模拟计算机的特点是数值由连续量来表示，运算过程也是连续的。\n\n电子数字计算机\n它是在算盘的基础上发展起来的，是用数目字来表示数量的大小。数字计算机的主要特点是按位运算，并且不连续地跳动计算。\n\n\n\n\n\n\n\n数字计算机\n模拟计算机\n\n\n\n\n数据表示方式\n数字 0/1\n电压\n\n\n计算方式\n数字计数\n电压组合和测量值\n\n\n控制方式\n程序控制\n盘上连线\n\n\n精度\n高\n低\n\n\n数据存储量\n大\n小\n\n\n逻辑判断能力\n强\n无\n\n\n\n\n1.2 数字计算机​        数字计算机根据计算机的效率、速度、价格、运行的经济性和适应性来划分，可以划分为两类：\n\n专用计算机\n专用机是最有效、最经济和最快速的计算机，但是它的适应性很差。\n\n通用计算机\n通用计算机适应性很大，但是牺牲了效率、速度和经济性。\n\n\n1.3 通用计算机​    通用计算机根据体积、简易性、功率损耗、性能指标、数据存储容量、指令规模和机器价格等可以分为：\n\n超级计算机\n大型机\n服务器\nPC机\n单片机\n多核机\n\n\n2 计算机发展简史2.1 计算机的五代变化\n第一代1946-1957年，电子管计算机：数据处理\n第二代1958-1964年，晶体管计算机：工业控制\n第三代1965-1971年，中小规模集成电路计算机：小型计算机\n第四代1972-1990年，大规模和超大规模集成电路计算机：微型计算机\n第五代1991年-至今，巨大规模集成电路计算机：单片机\n\n2.2 半导体存储器的发展\n20世纪50~60年代，所有计算机存储器都是由微小的铁磁体环\n\n1970年，仙童半导体公司生产出了第一个较大容量半导体存储器\n\n从1970年起，半导体存储器经历了11代：单个芯片\n1KB，4KB，16KB，64KB，256KB，1MB，4MB，16MB，64MB，256MB，GB\n\n其中 $1K=2^{10}$，$1M=2^{20}$，$1G=2^{30}$\n\n\n2.3 微处理器的发展\n1971年 Intel 公司开发出 Intel 4004。这是第一个将 CPU 的所有元件都放入同一块芯片内的产品，于是，微处理器诞生了。\n微处理器演变中的另一个主要进步是1972年出现的 Intel 8008，这是第一个8位微处理器，它比 4004 复杂一倍。\n1974年出现了 Intel 8080。这是第一个通用微处理器，而 4004 和 8008 是为特殊用途而设计的。8080 是为通用微机而设计的中央处理器。\n20世纪70年代末才出现强大的通用16位微处理器，8086便是其中之一。\n这一发展趋势中的另一阶段是在1981年，贝尔实验室和HP公司开发出了32位单片微处理器。\nIntel 于1985年推出了32位微处理器 Intel 80386。\n到现在的64位处理器和多核处理器\n\n2.4 计算机的性能指标\n吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S)。\n\n响应时间：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（$10^{-6}S$）、纳秒（$10^{-9}S$）。\n\n利用率：表示在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。\n\n处理机字长：指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。\n字长越长，表示计算的精度越高。\n\n总线宽度：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。\n\n存储器容量：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。\n其中 $K=2^{10}$，$M=2^{20}$，$G=2^{30}$，$T=2^{40}$，$B=8$ 位（1个字节）。\n存储器容量越大，记忆的二进制数越多。\n\n存储器带宽：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。\n\n主频：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（$f$）叫CPU的主频。\n度量单位是MHz（兆赫兹）、GHz（吉赫兹）。例如 Pentium 系列机为60MHz~266MHz，而 Pentium 4 升至3.6GHz。\n\n时钟周期：主频的倒数（$T$），即 $T=\\frac{1}{f}$，度量单位是微秒、纳秒。\n\nCPU执行时间：表示CPU执行一段程序所占用的CPU时间，可用下式计算：\n\nCPU执行时间=CPU时钟周期数\\times CPU时钟周期长\nCPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数。用下式计算：\n\nCPI=\\frac{执行某段程序所需的CPU时钟周期数}{该程序包含的指令条数}\nMIPS：表示每秒百万条指令数，用下式计算：\n\nMIPS=\\frac{指令条数}{程序执行时间\\times10^6}=\\frac{时钟频率}{CPI\\times10^6}MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。\n\nTe：程序执行时间，用下式计算：\n\nTe=\\frac{指令条数}{MIPS\\times10^6}\nMFLOPS：表示每秒百万次浮点操作次数，用下式计算：\n\nMFLOPS=\\frac{程序中的浮点操作次数}{程序执行时间\\times10^6}MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。\n\nTFLOPS：表示每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。\n\n\n\n\n3 计算机的硬件3.1 硬件组成要素\n\n\n\n\n\n\n\n\n通过一个例子了解数字计算机的主要组成和工作原理。\n\n用一个算盘、一张带有横格的纸和一支笔，要求我们计算 $y=ax+b-c$ 这样一个题目。\n解题步骤和数据记录在横格纸上。\n\n3.1.1 手工模仿计算机工作\n3.1.2 数字计算机基本组成\n控制器：人的大脑的操作控制功能\n运算器：人的大脑的计算功能\n存储器：人的大脑记忆功能\n输入设备：交互接口，笔\n输出设备：交互接口：纸\n\n3.1.3 冯·诺依曼型计算机\n存储程序\n按地址自动执行\n五大部件：包括控制器、运算器、存储器、输入设备、输出设备\n以运算器为中心\n\n\n3.1.4 现代计算机的体系结构\n现代的计算机已转为以存储器为中心。\n\n\n\n计算机的组成结构\n\n\n\n3.2 运算器\n算术运算和逻辑运算\n\n在计算机中参与运算的数是二进制的\n\n运算器的长度一般是8、16、32或64位\n\n\n\n3.3 存储器\n存储数据和程序（指令）\n\n容量（存储单元、存储单元地址、容量地址）\n\n分类内存（ROM、RAM）、外存\n\n存储器单位\n\n\n\n3.4 控制器\n指令和程序：指令的形式（操作和地址码、存储程序的概念、指令中程序和数据的存放、指令系统）\n\n指令和数据存储\n\n控制器的基本任务：按照一定的顺序一条接着一条取指令、指令译码、执行指令。取指周期和执行周期\n\n控制器完全可以区分开哪些是指令字，哪些是数据字。一般来讲，取指周期中从内存读出的信息流是指令流，它流向控制器；而在执行器周期中从内存读出的信息流是数据流，它由内存流向运算器。\n\n\n\n3.5 适配器与I/O设备\n输入设备：把人们所熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式\n输出设备：把计算机处理的结果变换为人或其他机器设备所能接收和识别的信息形式\n适配器：它使得被连接的外围设备通过系统总线与主机进行联系，以便使主机和外围设备并行协调地工作\n总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路\n\n​        总之，现代电子计算机是由运算器、存储器、控制器、适配器、总线和输入/输出设备组成的。这也是人们常说的计算机硬件。\n4 计算机的软件4.1 软件的组成与分类​        计算机软件相对计算机硬件来说是看不见，是计算机系统中不可少的无形部件。主要有两大类：\n\n系统软件：用来简化程序设计，简化使用方法，提高计算机的使用效率，发挥和扩大计算机的功能及用途。它包括以下四类：\n\n各种服务性程序，如诊断程序、排错程序、练习程序等\n语言程序，如汇编程序、编译程序、解释程序等\n操作系统\n数据库管理系统\n\n\n应用软件\n用户利用计算机来解决某些问题而编制的程序，如工程设计程序、数据处理程序、自动控制程序、企业管理程序、情报检索程序、科学计算程序等\n\n\n4.2 软件的发展演变\n编程语言的发展\n\n手编程序：机器语言程序，手工编译二进制码\n汇编程序：符号语言程序，汇编程序汇编\n高级程序：算法语言／高级语言，机器编译程序／解释程序\n\n\n系统软件的发展\n\n操作系统\n分布式系统软件\n\n\n\n5 计算机系统的层次结构5.1 多级计算机系统​        五级计算机层次系统\n\n第一级是微程序设计级。这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。\n第二级是一般机器级，也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。\n第三级是操作系统级，它由操作系统程序实现。这些操作系统由机器指令和广义指令组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。\n第四级是汇编语言级，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。\n第五级是高级语言级，它是面向用户的，为方使用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行。\n\n5.2 软件与硬件逻辑等价性\n随着大规模集成电路技术的发展和软件硬化的超势，计算机系统的软、硬件界限已经变得模糊了。因为任何操作可以由软件来实现，也可以由硬件来实现；任何指令的执行可以由硬件完成，也可以由软件来完成。\n任何操作可以由软件来实现也可以由硬件来实现（设计计算机系统时，应考虑各个方面的因素：价格、速度可靠性、存储容量、变更周期）\n实体硬件机功能的扩大\n固件的概念（功能上是软件，形态上是硬件）\n\n","slug":"1 计算机系统概论","date":"2022-10-02T10:37:36.000Z","categories_index":"Computer Organization","tags_index":"Computer Organization","author_index":"Brandon"},{"id":"1c444fa0484aa2cb0030ecd852dcfc6a","title":"User Center","content":"用户中心笔记目标：完整了解做项目的思路，接触一些企业级的开发技术，轻松做出管理系统。\n企业做项目流程需求分析 =&gt; 设计（概要设计、详细设计）=&gt; 技术选型 =&gt; 初始化 / 引入需要的技术 =&gt; 写 Demo =&gt; 写代码（实现业务逻辑） =&gt; 测试（单元测试、系统测试）=&gt; 代码提交 / 代码评审 =&gt; 部署 =&gt; 发布上线\n需求分析\n登录 / 注册\n用户管理（仅管理员可见）对用户的查询或者修改\n用户校验（仅星球用户可见）\n\n技术选型前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）\n后端：\n\njava\nspring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）\nspringmvc（web 框架，提供接口访问、restful接口等能力）\nmybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）\nmybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）\nspringboot（快速启动 / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）\njunit 单元测试库\nmysql 数据库\n\n部署：服务器 / 容器（平台）\n3 种初始化 Java 项目的方式\nGitHub 搜现成的代码\nSpringBoot 官方的模板生成器（https://start.spring.io/）\n直接在 IDEA 开发工具中生成  ✔\n\n如果要引入 java 的包，可以去 maven 中心仓库寻找（http://mvnrepository.com/）\n数据库设计什么是数据库？存数据的\n数据库里有什么？数据表（理解为 excel 表格）\njava 操作数据库？程序代替人工\n什么是设计数据库表？有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？\n举例：性别是否需要加索引？\n用户表设计\n\n\n\n字段\n名称\n类型\n\n\n\n\nid\n主键\nbigint\n\n\nusername\n昵称\nvarchar\n\n\nuserAccount\n登录账号\nvarchar\n\n\navatarUrl\n头像\nvarchar\n\n\ngender\n性别\ntinyint\n\n\nuserPassword\n密码\nvarchar\n\n\nphone\n电话\nvarchar\n\n\nemail\n邮箱\nvarchar\n\n\nuserStatus\n用户状态\nint  0 - 正常\n\n\ncreateTime\n创建时间（数据插入时间）\ndatetime\n\n\nupdateTime\n更新时间（数据更新时间）\ndatetime\n\n\nisDelete\n是否删除 0 1（逻辑删除）\ntinyint\n\n\nuserRole\n用户角色\n0 - 普通用户 1 - 管理员\n\n\n\n\n自动生成器的使用MyBatisX 插件，自动根据数据库生成：\n\ndomain：实体对象\nmapper：操作数据库的对象\nmapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL\nservice：包含常用的增删改查\nserviceImpl：具体实现 service\n\n从而提高开发效率！\n注册逻辑设计\n用户在前端输入账户和密码、以及校验码（todo）\n校验用户的账户、密码、校验密码，是否符合要求\n非空\n账户长度 不小于 4 位\n密码就 不小于 8 位吧\n账户不能重复\n账户不包含特殊字符\n密码和校验密码相同\n\n\n对密码进行加密（密码千万不要直接以明文存储到数据库中）\n向数据库插入用户数据\n\n登录功能接口设计接受参数：用户账户、密码\n请求类型：POST \n请求体：JSON 格式的数据\n\n\n\n\n\n\n\n\n\n请求参数很长时不建议用 get\n返回值：用户信息（ 脱敏 ）\n登录逻辑\n校验用户账户和密码是否合法\n\n非空\n账户长度不小于 4 位\n密码就不小于 8 位\n账户不包含特殊字符\n\n\n校验密码是否输入正确，要和数据库中的密文密码去对比\n\n用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露\n\n我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）\ncookie\n\n返回脱敏后的用户信息\n\n\n实现控制层 Controller 封装请求\napplication.yml 指定接口全局路径前缀：\nservlet:\n  context-path: &#x2F;api\n控制器注解：\n@RestController 适用于编写 restful 风格的 api，返回值默认为 json 类型\n校验写在哪里？\n\ncontroller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）\nservice 层是对业务逻辑的校验（有可能被 controller 之外的类调用）\n\n如何知道是哪个用户登录了？\n\n\n\n\n\n\n\n\njavaweb 这一块的知识\n\n连接服务器端后，得到一个 session 状态（匿名会话），返回给前端\n\n登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ \nsession =&gt; cookie \n\n前端接收到后端的命令后，设置 cookie，保存到浏览器内\n\n前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求\n\n后端拿到前端传来的 cookie，找到对应的 session\n\n后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）\n\n\n用户管理接口设计关键：必须鉴权！！！\n\n查询用户（允许根据用户名查询）\n删除用户\n\n写代码流程\n先做设计\n代码实现\n持续优化！！！（复用代码、提取公共逻辑 / 常量）\n\n前后端交互前端需要向后端发送请求才能获取数据 / 执行操作。\n怎么发请求：前端使用 ajax 来请求后端\n前端请求库及封装关系\naxios 封装了 ajax\n\nrequest 是 ant design 项目又封装了一次\n\n\n追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件\n代理正向代理：替客户端向服务器发送请求，可以解决跨域问题\n反向代理：替服务器统一接收请求。\n怎么实现代理？\n\nNginx 服务器\nNode.js 服务器\n\n举例原本请求：http://localhost:8000/api/user/login\n代理到请求：http://localhost:8080/api/user/login\n\n前端框架介绍Ant Design Pro（Umi 框架）权限管理\napp.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）\naccess.ts 控制用户的访问权限\n\n获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。\nProComponents 高级表单\n通过 columns 定义表格有哪些列\ncolumns 属性\ndataIndex 对应返回数据对象的属性\ntitle 表格列名\ncopyable 是否允许复制\nellipsis 是否允许缩略\nvalueType：用于声明这一列的类型（dateTime、select）\n\n\n\n框架关系Ant Design 组件库 =&gt; 基于 React 实现\nAnt Design Procomponents =&gt; 基于 Ant Design 实现\nAnt Design Pro 后台管理系统 =&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现\n其他知识MFSU：前端编译优化\n后端优化通用返回对象目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败\n200、404、500、502、503\n&#123;\n    &quot;name&quot;: &quot;Brandon&quot;\n&#125;\n\n↓\n\n&#x2F;&#x2F; 成功\n&#123;\n    &quot;code&quot;: 0 &#x2F;&#x2F; 业务状态码\n    &quot;data&quot;: &#123;\n        &quot;name&quot;: &quot;Brandon&quot;\n    &#125;,\n\t&quot;message&quot;: &quot;ok&quot;\n&#125;\n\n\n&#x2F;&#x2F; 错误\n&#123;\n    &quot;code&quot;: 50001 &#x2F;&#x2F; 业务状态码\n    &quot;data&quot;: null\n\t&quot;message&quot;: &quot;用户操作异常、xxx&quot;\n&#125;\n自定义错误码，返回类支持返回正常和错误\n封装全局异常处理器实现\n定义业务异常类\n\n相对于 java 的异常类，支持更多字段\n自定义构造函数，更灵活 / 快捷的设置字段\n\n\n编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）\n\n作用\n捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 / 信息\n同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）\n集中处理，比如记录日志\n\n前端优化\n\n\n\n\n\n\n\n\n直播的 0：00 - 0：35 为踩坑过程，可跳过\n全局响应处理应用场景：我们需要对接口的 通用响应 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。\n优势：不用在每个接口请求中都去写相同的逻辑\n实现：参考你用的请求封装工具的官方文档，比如 umi-request（https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用 axios，参考 axios 的文档。\n创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。\n用户校验\n\n\n\n\n\n\n\n\n仅适用于用户可信的情况\n先让用户自己填：2 - 5 位编号，全凭自觉。\n后台补充对编号的校验：长度校验、唯一性校验\n前端补充输入框，适配后端。\n\n\n\n\n\n\n\n\n\n后期拉取星球数据，定期清理违规用户\n多环境参考文章：https://blog.csdn.net/weixin_41701290/article/details/120173283\n本地开发：localhost（127.0.0.1）\n多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。\n为什么需要？\n\n每个环境互不影响\n区分不同的阶段：开发 / 测试 / 生产\n对项目进行优化：\n本地日志级别\n精简依赖，节省项目体积\n项目的环境 / 参数可以调整，比如 JVM 参数\n\n\n\n针对不同环境做不同的事情。\n多环境分类：\n\n本地环境（自己的电脑）localhost\n开发环境（远程开发）大家连同一台机器，为了大家开发方便\n测试环境（测试）开发 / 测试 / 产品，单元测试 / 性能测试 / 功能测试 / 系统集成测试，独立的数据库、独立的服务器\n预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题\n正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行\n沙箱环境（实验环境）：为了做实验\n\n前端多环境实战\n请求地址\n\n开发环境：localhost:8000\n\n线上环境：user-backend.code-nav.cn\n\n\nstartFront(env) &#123;\n    if(env &#x3D;&#x3D;&#x3D; &#39;prod&#39;) &#123;\n        &#x2F;&#x2F; 不输出注释 \n        &#x2F;&#x2F; 项目优化\n        &#x2F;&#x2F; 修改请求地址\n    &#125; else &#123;\n        &#x2F;&#x2F; 保持本地开发逻辑\n    &#125;\n&#125;\n用了 umi 框架，build 时会自动传入 NODE_ENV == production 参数，start NODE_ENV 参数为 development\n\n启动方式\n\n开发环境：npm run start（本地启动，监听端口、自动更新）\n线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）\n\n\n项目的配置\n不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：https://umijs.org/zh-CN/docs/deployment\n\n开发环境：config.dev.ts\n生产环境：config.prod.ts\n公共配置：config.ts 不带后缀\n\n\n\n后端多环境实战SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件\n可以在启动项目时传入环境变量：\njava -jar .\\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;prod\n主要是改：\n\n依赖的环境地址\n\n数据库地址\n\n缓存地址\n\n消息队列地址\n\n项目端口号\n\n\n\n服务器配置\n\n\n项目部署参考文章：https://www.bilibili.com/read/cv16179200\n需要 Linux 服务器（建议大家用 CentOS 8+ / 7.6 以上）\n原始部署什么都自己装\n前端需要 web 服务器：nginx 、apache、tomcat\n安装 nginx 服务器：\n\n用系统自带的软件包管理器快速安装，比如 centos 的 yum\n\n自己到官网安装（参考文章）\ncurl -o nginx-1.21.6.tar.gz http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.21.6.tar.gz\n\ntar -zxvf nginx-1.21.6.tar.gz\n\ncd nginx-1.21.6\n\n   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y\n   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y\n   41  2022-04-17 23:31:57 .&#x2F;configure --with-http_ssl_module --with-http_v2_module --with-stream\n   42  2022-04-17 23:32:13 make\n   43  2022-04-17 23:32:54 make install\n   48  2022-04-17 23:33:40 ls &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx\n   vim &#x2F;etc&#x2F;profile\n  在最后一行添加：export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin\t\n  \n  nginx\n  \n  netstat -ntlp 查看启动情况\n注意 nginx 权限\n\n\n后端java、maven\n安装：\nyum install -y java-1.8.0-openjdk*\n\ncurl -o apache-maven-3.8.5-bin.tar.gz https:&#x2F;&#x2F;dlcdn.apache.org&#x2F;maven&#x2F;maven-3&#x2F;3.8.5&#x2F;binaries&#x2F;apache-maven-3.8.5-bin.tar.gz\n\ngit clone xxx 下载代码\n\n打包构建，跳过测试\nmvn package -DskipTests\n\njava -jar .&#x2F;user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;prod\n宝塔 Linux 部署Linux 运维面板\n官方安装教程：https://www.bt.cn/new/download.html\n方便管理服务器、方便安装软件\n前端托管前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）\n\n\n\n\n\n\n\n\n\nhttps://console.cloud.tencent.com/webify/new\n\n小缺点：需要将代码放到代码托管平台上\n优势：不用写命令、代码更新时自动构建\n\nDocker 部署docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。\n再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。\ndocker 可以理解为软件安装包。\nDocker 安装：https://www.docker.com/get-started/ 或者宝塔安装\nDockerfile 用于指定构建 Docker 镜像的方法\nDockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）\nDockerfile 编写：\n\nFROM 依赖的基础镜像\nWORKDIR 工作目录\nCOPY 从本机复制文件\nRUN 执行命令\nCMD / ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令\n\n根据 Dockerfile 构建镜像：\n# 后端\ndocker build -t user-center-backend:v0.0.1 .\n\n# 前端\ndocker build -t user-center-frontend:v0.0.1 .\nDocker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）\ndocker run 启动：\n# 前端\ndocker run -p 80:80 -d user-center-frontend:v0.0.1\n\n# 后端\ndocker run -p 8080:8080 user-center-backend:v0.0.1\n虚拟化\n\n端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联\n目录映射：把本机的端口和容器应用的端口进行关联\n\n进入容器：\ndocker exec -i -t  fee2bbb7c9ee &#x2F;bin&#x2F;bash\n查看进程：\ndocker ps \n查看日志：\ndocker logs -f [container-id]\n杀死容器：\ndocker kill\n强制删除镜像：\ndocker rmi -f\nDocker 平台部署\n云服务商的容器平台（腾讯云、阿里云）\n面向某个领域的容器平台（前端 / 后端微信云托管）要花钱！\n\n容器平台的好处：\n\n不用输命令来操作，更方便省事\n不用在控制台操作，更傻瓜式、更简单\n大厂运维，比自己运维更省心\n额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）\n\n绑定域名前端项目访问流程：用户输入网址 =&gt; 域名解析服务器（把网址解析为 ip 地址 / 交给其他的域名解析服务） =&gt; 服务器 =&gt;（防火墙）=&gt; nginx 接收请求，找到对应的文件，返回文件给前端 =&gt; 前端加载文件到浏览器中（js、css） =&gt; 渲染页面\n后端项目访问流程：用户输入网址 =&gt; 域名解析服务器 =&gt; 服务器 =&gt; nginx 接收请求 =&gt; 后端项目（比如 8080端口）\nnginx 反向代理的作用：替服务器接收请求，转发请求\n跨域问题解决浏览器为了用户的安全，仅允许向 同域名、同端口 的服务器发送请求。\n如何解决跨域？\n最直接的方式：把域名、端口改成相同的\n添加跨域头让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）\n1. 网关支持（Nginx）# 跨域配置\nlocation ^~ &#x2F;api&#x2F; &#123;\n    proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;;\n    add_header &#39;Access-Control-Allow-Origin&#39; $http_origin;\n    add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n    add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;\n    add_header Access-Control-Allow-Headers &#39;*&#39;;\n    if ($request_method &#x3D; &#39;OPTIONS&#39;) &#123;\n        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n        add_header &#39;Access-Control-Allow-Origin&#39; $http_origin;\n        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\n        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#39;;\n        add_header &#39;Access-Control-Max-Age&#39; 1728000;\n        add_header &#39;Content-Type&#39; &#39;text&#x2F;plain; charset&#x3D;utf-8&#39;;\n        add_header &#39;Content-Length&#39; 0;\n        return 204;\n    &#125;\n&#125;\n2. 修改后端服务\n配置 @CrossOrigin 注解\n\n添加 web 全局请求拦截器\n@Configuration\npublic class WebMvcConfg implements WebMvcConfigurer &#123;\n \n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n        &#x2F;&#x2F;设置允许跨域的路径\n        registry.addMapping(&quot;&#x2F;**&quot;)\n                &#x2F;&#x2F;设置允许跨域请求的域名\n                &#x2F;&#x2F;当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】\n                .allowedOrigins(&quot;http:&#x2F;&#x2F;localhost:9527&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:9527&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8082&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8083&quot;)\n                &#x2F;&#x2F;是否允许证书 不再默认开启\n                .allowCredentials(true)\n                &#x2F;&#x2F;设置允许的方法\n                .allowedMethods(&quot;*&quot;)\n                &#x2F;&#x2F;跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n\n定义新的 corsFilter Bean，参考：https://www.jianshu.com/p/b02099a435bd\n\n\n项目优化点\n功能扩充\n管理员创建用户、修改用户信息、删除用户\n上传头像\n按照更多的条件去查询用户\n更改权限\n\n\n修改 Bug\n项目登录改为分布式 session（单点登录 - redis）\n通用性\nset-cookie domain 域名更通用，比如改为 *.xxx.com\n把用户管理系统 =&gt; 用户中心（之后所有的服务都请求这个后端）\n\n\n后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）\n\n","slug":"User Center","date":"2022-08-05T09:01:36.000Z","categories_index":"Project","tags_index":"Project","author_index":"Brandon"}]